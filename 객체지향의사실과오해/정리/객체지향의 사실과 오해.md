### 객체지향, 객체

<mark>객체지향</mark> 

- 현실 속에 존재하는 것들을 소프트웨어 내부로 옮겨오는 작업

<mark>객체</mark>

- 현실 세계에 존재하는 사물에 대한 추상화

말 자체는 현실을 반영하는 것 같지만, 목표는 실세계를 모방하는 것이 아니라 <b>새로운 세계를 창조하는 것</b>이다.
실세계를 소프트웨어 안으로 옮겨 담는 것이 아니라 고객과 사용자를 만족할 수 있는 세계 창조하는 것이다.
일상생활 속에 <b>역할, 책임, 협력</b>이 스며들어있다.



### 객체의 역할

여러 객체가 <b>동일한 역할을 수행</b>할 수 있다.
역할은 <b>대체 가능성</b>을 의미한다.
각 객체는 책임을 수행하는 방법을 <b>자율적</b>으로 선택할수있다
하나의 객체가 <b>동시에 여러 역할을 수행</b>할 수 있다.



### 객체의 특징

객체지향이란 시스템을 상호작용하는 자율적인 객체들의 공동체로 바라보고 객체를 이용해 시스템을 분할하는 방법이다.

- <b>상태, 행동</b>을 함께 지닌 실체
- 충분히 <b>협력적</b>이어야한다 (단순 복종이 아닌 요청에 응답)
  - 시스템의 행위를 구현하기 위해 다른 객체와 협력한다. 
  - 각 객체는 협력 내에서 정해진 역할을 수행하며 역할은 관련된 책임의 집합이다.
- 객체는 <b>자율적</b>이어야한다
  - 자율적인 객체란 상태와 행위를 함께 지니며 스스로 자기 자신을 책임지는 객체를 의미한다.
- 객체는 <b>유일하게 식별가능</b>하다.



##### 객체는 다른 객체와 협력하기 위해 메세지를 전송하고, 메세지를 수신한 객체는 메시지를 처리하는 데 적합한 메서드를 자율적으로 선택한다.



### 역할, 책임, 협력에 집중하라

클래스가 중요한 것이 아니라 <b>객체 역할, 책임, 협력에 집중하는 것이 중요</b>하다.
객체지향은 <b>객체를 지향하는 것이지 클래스를 지향하는 것이 아니다.</b>



#### 상태

과거에 발생한 행동 자체로 결과를 판단하기에는 복잡도가 높다.

상태는 근본적으로 세상의 복잡성을 완화하고 인지 과부하를 줄일 수 있다.

이를 위해 상태라는 개념을 도입해 <b>결과의 상태를 저장</b>한다.

- 객체는 상태를 가지며 상태는 <b>변경 가능</b>하다.
- 상태를 변경하는 것은 <b>행동</b>이다.
- 행동의 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있다.
- 행동의 순서가 결과에 영향을 미친다.



#### 프로퍼티

객체의 상태를 구성하는 모든 특징을 통틀어 프로퍼티라고 한다.

상태는 특정 시점에 객체가 가지고 있는 정보의 집합으로 구조적 특징을 표현한다.
객체의 상태는 객체에 존재하는 정적인 프로퍼티와 동적인 프로퍼티 값으로 구성된다.

객체의 프로퍼티는 단순한 값과 다른 객체를 참조하는 링크로 구분할 수 있다.
객체 자율적인 존재이기에 상태에 직접 접근하거나 변경할 수 없다.

프로퍼티는 <b>정적</b>이다. 

- 단순 속성과 링크로 이루어져 있다.
  - 객체를 구성하는 단순한 값은 <b>속성</b>이다.
  - 객체와 객체 사이의 의미 있는 연결을 <b>링크(Link)</b>라고 한다.
  - 링크가 존재해야만 메시지를 주고받을 수 있다.
    - 속성 : 앨리스의 키, 위치
    - 링크 : 음료

프로퍼티 값은 <b>동적</b>이다.

- 앨리스의 키 : 130->80
- 위치 : 침대->정원
- 음료의 양 : 0.5l->0.3l




#### 행동

행동이란 외부의 요청 또는 수신된 메세지에 응답하기 위해 동작하고 반응하는 활동이다.
행동의 결과로 객체는 자신의 상태를 변경하거나 다른 객체에게 메세지를 전달할 수 있다.
객체는 행동을 통해 다른 객체와의 협력에 참여하므로 행동은 <b>외부에 가시적</b>이어야 한다.

- 객체의 상태를 변경시키지만 행동의 결과는 객체의 상태에 의존적이다.
- 상태에 영향을 받는다.
- 객체의 행동은 상태를 변화시킨다.



#### 객체의 행동에 따른 두 가지 관점의 부수효과

- 객체 자신의 상태 변경
- 행동 내에서 협력하는 다른 객체에 대한 메세지 전송



#### 객체는 자율적인 존재이다. 따라서, 누군가 함부로 다른 객체의 상태를 변경할 수 없다

#### e.g)음료는 스스로 자신의 양을 줄여야한다

객체는 상태를 캡슐 안에 감춰둔 채 외부로 노출하지 않는다.
객체가 외부에 노출하는 것은 행동뿐이며, 외부에서 객체에 접근할 수 있는 유일한 방법 역시 행동뿐이다.
외부의 객체는 요청한 객체의 상태가 변한지 사실조차 모른다.
잘 정의된 행동 집합 뒤로 상태를 캡슐화하는 것은 객체의 자율성을 높이고 협력을 단순하고 유연하게 만든다.



#### 식별자

객체가 식별 가능하도록 하는 특별한 프로퍼티가 바로 <b>식별자</b>이다.
<b>모든 객체가 식별자 값을 가지지만 단순한 값은 식별자를 가지지 않는다.</b>
값과 객체의 가장 큰 차이점은 값은 식별자를 가지지 않지만 객체는 식별자를 가진다.
시스템을 설계할 때는 이 차이점을 명확하게 구분하고 명시적으로 표현해야한다.

- 값은 불변 상태를 가진다. (상태가 같다면 같은 것이다 -> 동등성)
- 객체는 동일한 것이라고 판단할 수 있는 식별자를 가진다(식별자를 기반으로 판단한다 -> 동일성)
  - 객체는 시간에 따라 변경되는 상태를 포함하기에 단순히 값 비교만으로는 불가하다(가변 상태를 가진다.)



값은 식별자를 가지지 않기 때문에 상태를 이용한 동등성 검사를 통해 두 인스턴스를 비교해야한다.
객체는 상태가 변경될 수 있기 때문에 식별자를 이용한 동일성 검사를 통해 두 인스턴스를 비교할 수 있다.



#### 객체를 설계할 때 상태를 먼저 결정하고 행동을 나중에 결정하는 실수를 범하지 말자.

#### 상태를 먼저 결정할 경우 캡슐화가 저해된다.

#### 객체를 협력자가 아닌 고립된 섬으로 만든다. (협력에 적합하지 못한 객체를 창조한다.)

#### 객체의 재사용성이 저하된다. (다양한 협력에 참여하는 능력에서 재사용성이 나온다.)

따라서, 행동을 먼저 결정하자.
객체지향 설계는 애플리케이션에 필요한 협력을 생각하고 협력에 참여하는 데 필요한 행동을 생각한 후 행동을 수행할 객체를 선택한다.



### 객체 지향은 현실 세계의 모방이 아닌 은유

객체지향은 현실 세계의 모방이라고 하곤 한다.
그에 따라 현실 세계에 존재하는 다양한 객체를 모방한 후 필요한 부분만 취해 소프트웨어 객체로 구현하는 과정이라고 설명한다. (현실 세계를 모방해서 단순화한다는 추상화라고도 한다.)
하지만 객체지향 세계는 현실 세계의 단순한 모방이 아니다.
현실 속에서 수동적인 존재가 소프트웨어 객체로 구현될 때는 능동적으로 변한다.
현실의 객체보다 더 많은 일을 할 수 있는 소프트웨어 객체의 특징을 의인화라고 한다.

소프트웨어 객체가 현실 세계의 객체와는 전혀 다르다.
그렇다고 전혀 상관이 없다는 것은 아니다.
모방이나 추상화의 수준이 아닌 다른 관점에서 유사성을 가지고 있을 뿐이다.
이를 표현하는 단어는 은유이다.
현실 객체의 은유를 효과적으로 사용할 경우 표현적 차이를 줄일 수 있으며 이해하기 쉽고 유지보수가 용이한 소프트웨어를 만들 수 있다.



### 추상화를 통한 복잡성 극복

진정한 의미에서 추상화란 현실에서 출발하되 불필요한 부분을 도려내가면서 사물의 놀라운 본질을 드러나게 하는 과정
불필요한 부분을 무시함으로써 현실에 존재하는 복잡성을 극복



### 추상화란

어떤 양상, 세부 사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법

- 구체적인 사물들 간의 공통점은 취하고 차이점은 버리는 일반화를 통해 단순화
- 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순화
- 추상화의 목적은 복잡성을 이해하기 쉬운 수준으로 단순화



### 개념

객체지향 패러다임의 중심에는 구체적이고 실제적인 객체가 존재하지만 수많은 객체들을 개별적인 단위로 취급하기에는 인간이 지닌 인지능력은 턱없이 부족하다.
사람들은 본능적으로 공통적인 특성을 기준으로 객체를 여러 그룹으로 묶어 단순화하려한다.
공통점을 기반으로 객체들을 묶기 위한 그릇을 개념이라고 한다.

- 심볼 - 개념을 가리키는 간략한 이름이나 명칭
- 내연 - 개념의 완전한 정의를 나타내며 내연의 의미를 이용해 객체가 개념에 속하는지 여부를 확인
- 외연 - 개념에 속하는 모든 객체의 집합



### 분류

분류란 객체에 특정한 개념을 적용하는 작업

객체에 특정한 개념을 적용하기로 결심했을 때 우리는 그 객체를 특정한 집합의 멤버로 분류하고 있는 것이다.
분류는 객체지향의 가장 중요한 개념 중 하나다.
어떤 객체를 어떤 개념으로 분류할지가 객체지향의 품질을 결정한다.



e.g )

- 심볼 - 자동차
- 내연 - 자체 엔진에서 만든 동력을 바퀴에 전달하여 지상에서 승객이나 화물을 운반할 수 있다.
- 외연 - 세단, SUV ..



### 분류는 추상화를 위한 도구다.

추상화의 첫 번쨰 차원은 공통점을 취하고 차이점은 버려 단순화한다.
추상화의 두 번째 차원은 중요한 부분을 강조하기 위해 세부적인 것을 버려 단순화한다.
분류하는 과정은 두 가지를 모두 사용한다.



### 타입

타입은 개념과 동일하다.
타입이란 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념을 의미한다.
어떤 객체에 타입을 적용할 수 있을 때 그 객체를 타입의 인스턴스라고 한다.
타입의 인스턴스는 타입을 구성하는 외연인 객체 집합의 일원이 된다.
데이터 타입은 메모리 안에 저장된 데이터의 종류를 분류하는 데 사용하는 메모리 집합에 관한 메타데이터이다.
데이터에 대한 분류는 암시적으로 어떤 종류의 연산이 해당 데이터에 대해 수행될 수 있는지를 결정한다.

​           

객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 행동이다.
동일한 행동을 수행한다면 그 객체들은 동일한 타입으로 분류될 수 있다.
객체의 내부적인 표현은 외부로부터 철저하게 감춰진다.
객체의 행동을 가장 효과적으로 수행할 수만 있다면 객체 내부의 상태를 어떤 방식으로 표현하더라도 무방하다.
같은 행동을 한다 -> 같은 책임을 가진다 -> 같은 메세지를 수신한다.
다형성개념에서 이 부분을 살펴볼 수 있다.
같은 메세지를 수신한다 -> 같은 타입이다. 그렇지만 동일한 결과를 내뱉지는 않는다 (why? 객체 내부의 상태가 다를 수 있기에)



### 일반화/특수화

집합의 개념으로 보자면 더한 기능을 할 수 있는 특수한 개념이 부분집합이 된다.
객체의 일반화/특수화 관계에 있어서도 중요한 것은 객체가 내부에 보관한 데이터가 아니라 객체가 외부에 제공하는 행동이다.

객체의 모양을 빚는 것은 객체가 참여하는 협력이다.
어떤 협력에 참여하는지가 객체에 필요한 행동을 결정하고 필요한 행동이 객체의 상태를 결정한다.



### 슈퍼타입과 서브타입

슈퍼타입(일반적관계), 서브타입(특수적관계)
슈퍼타입과 서브타입에서 중요한 것은 두 타입 간의 관계가 행동에 의해 결정된다.

일반화는 추상화를 위한 도구다.
추상화의 두 번째 차원은 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거하여 단순하게 만드는 것이다.
일반화/특수화 계층은 객체지향 패러다임에서 추상화의 두 번째 차원을 적절하게 활용한다.



### 역할은 객체지향 설계의 단순성, 유연성, 재사용성을 뒷받침하는 핵심 개념

역할을 이용하면 협력을 추상화함으로써 단순화할 수 있다.
객체가 역할을 대체하기 위해서는 행동이 호환돼야 한다.
어떤 객체가 역할을 대체 가능하기 위해서는 협력 안에서 역할이 수행하는 모든 책임을 동일하게 수행할 수 있어야 한다. (추가적인 책임도 이행할 수 있다.)
역할의 대체 가능성은 행위 호환성이다.

객체는 시스템에 필요한 데이터를 저장하기 위해서가 아니라 행위를 수행하며 협력에 참여하기 위해서다. 따라서 실제로 중요한 것은 객체의 행동, 즉 책임이다.

객체지향이 클래스와 클래스 간의 관계를 표현하는 시스템의 정적인 측면에 중점을 두는 것이 아니라 중요한 것은 협력에 참여하는 동적인 객체이며 클래스는 단지 시스템에 필요한 객체를 표현하고 생성하기 위한 구현 매커니즘이다.

올바른 객체를 설계하기 위해서는 먼저 견고하고 깔끔한 협력을 설계해야한다. 협력을 설계한다는 것은 설계에 참여하는 객체들이 주고받을 요청과 응답의 흐름을 결정한다는 것이다. 이렇게 결정된 요청과 응답의 흐름은 객체가 협력에 참여하기 위해 수행될 책임이 된다.



### 책임 주도 설계 - 객체의 책임을 중심으로 시스템을 구축하는 설계 방법

시스템의 기능은 더 작은 규모의 책임으로 분할되고 각 책임은 책임을 수행할 적절한 객체에게 할당된다. 

스스로 처리할 수 없는 정보나 기능이 필요한 경우 적절한 객체를 찾아 작업을 요청한다. 이처럼 협력 관계가 만들어진다.

즉, 시스템의 책임을 객체의 책임으로 변환하고 각 객체가 책임을 수행하는 중에 필요한 정보나 서비스를 제공해줄 협력자를 찾아 해당 협력자에게 책임을 할당하는 순차적인 방식으로 객체들의 협력 공동체를 구축한다.

개별적인 객체의 상태가 아니라 객체의 책임과 상호작용에 집중한다.

1. 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
2. 시스템 책임을 더 작은 책임으로 분할한다.
3. 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
4. 객체가 책임을 수행하는 중에 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
5. 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.



### 디자인 패턴 - 책임-주도 설계의 결과를 표현

반복적으로 발생하는 문제와 그 문제에 대한 해법의 쌍으로 정의된다.



### TDD - 테스트를 기반으로 설계를 진행

테스트를 먼저 작성하고 그에 맞는 설계를 진행한다. (좋은 객체지향을 이끌어낼 수 있다.)



### 최대한 변화에 안정적인 인터페이스를 만들기 위해서는 인터페이스를 통해 구현과 관련된 세부 사항이 드러나지 않게 해야 한다.

개념 관점에서 바라보면 소프트웨어 클래스가 도메인 개념의 특성을 최대한 수용하면 변경을 관리하기 쉽고 유지보수성을 향상시킬 수 있다. 소프트웨어 클래스와 도메인 클래스 사이의 간격이 좁으면 좁을수록 기능을 변경하기 위해 뒤적거려야 하는 코드의 양도 점점 줄어든다.



### 코드의 세 가지 관점

#### 구현 관점은 클래스의 내부 구현을 바라본다.

클래스의 메서드와 속성은 구현에 속하며 공용 인터페이스의 일부가 아니기에 메서드의 구현과 속성의 변경이 원칙적으로 외부의 객체에 영향을 미치면 안 된다.

#### 명세 관점은 클래스의 인터페이스를 바라본다.

클래스의 public 메서드는 다른 클래스가 협력할 수 있는 공용 인터페이스를 드러낸다.
인터페이스를 수정하면 해당 객체와 협력하는 모든 객체에게 영향을 미칠 수밖에 없다.
수정하기 어렵다는 사실을 명심하자.

#### 객체란 식별 가능한 개체 또는 사물이다.

객체는 자동차처럼 만질 수 있는 구체적인 사물일 수도 있고, 시간처럼 추상적인 개념일 수도 있다.
객체는 구별 가능한 식별자, 특징적인 행동, 변경 가능한 상태를 가진다.
소프트웨어 안에서 객체는 저장된 상태와 실행 가능한 코드를 통해 구현된다.

### 인터페이스와 구현을 분리

명세 관점 <-> 구현 관점
명세 관점과 구현 관점이 뒤섞이게 하지마라
인터페이스가 구현 세부 사항을 노출하기 시작하면 아주 작은 변동에도 전체 협력이 요동친다.

### 추상화 기법

#### 분류와 인스턴스화

객체의 구체적인 세부 사항은 숨기고 인스턴스 간에 공유하는 공통적인 특성을 기반으로 범주를 형성하는 과정이다. 분류의 역은 범주로부터 객체를 생성하는 인스턴스화 과정이다.

#### 일반화와 특수화

범주 사이의 차이를 숨기고 범주 간에 공유하는 공통적인 특성을 강조한다. 일반화의 역을 특수화라고 한다.
Is-a 규칙
보통 상속을 의미 -> 구조적인 순응(우리가 흔히 아는 Is-a), 행위적인 순응(리스코프 치환 원칙)

#### 집합과 분해

집합은 부분과 관련된 세부 사항을 숨기고 부분을 사용해서 전체를 형성하는 과정을 가리킨다. 집합의 반대 과정은 전체를 부분으로 분리하는 분해 과정이다.

다중 분류와 동적 분류보다는 단일 분류와 정적 분류를 선택하자.