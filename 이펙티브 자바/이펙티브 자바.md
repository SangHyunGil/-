# 객체의 생성과 파괴

### 생성자 대신 정적 팩터리 메서드를 고려하라

정적 팩터리 메서드

```java
LocalTime openTime = LocalTime.of(9, 30);
```

- 그 클래스의 인스턴스를 반환하는 단순한 정적 메서드

- 장점

  - 이름을 가질 수 있다.

    - BigInteger vs BigInteger.probablePrime => 소수를 반환한다라는 의미는 후자가 더 잘 나타낸다.
    - 시그니처가 같은 생성자가 여러 개 필요할 것 같으면, 생성자를 정적 팩터리 메서드로 바꾸고 각각의 차이를 잘 드러내는 이름으로 지어주면 된다.

  - 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.

    ```java
    String str1 = "GSH";    //1. "GSH" 인스턴스를 생성
    String str2 = "GSH";    //2. 생성된 "GSH" 인스턴스를 재활용
    ```

    - 불변 클래스 같은 경우 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하고 있다.

      > 불변 클래스는 heap 영역에 생성되며 변경 불가능한 클래스이며 가변적이지 않는 클래스이다.
      >
      > - heap 영역에서 값 자체가 변경되는 것이 아니라, 대체되는 것이다. (방어적 복사-defensive-copy)
      >   - String a = "G"; a = "SH"; 라면 G가 SH로 바뀌는 것이 아니라 SH로 대체되는 것이다.
      >   - 단, StringBuffer는 가변 객체이다. 
      >
      > 불변 클래스에는 String, Boolean, Integer, Float, Long 등이 존재한다.
      >
      > 레퍼런스 타입의 객체이기 때문에된다.
      >
      >
      > 왜 사용해야 할까?
      >
      > - "불변"이기에 쓰기에 대한 큰 걱정이 없어 Thread-Safe하여 병렬 프로그래밍에 유용하며, 동기화를 고려하지 않아도 된다.
      >
      >   
      >
      > - "불변"이기에 Cache, Map, Set 등의 요소로 상당히 적합하다.
      >
      > - "불변"이기에 부수 효과의 가능성을 크게 줄일 수 있다.
      >
      > - "불변"이기에 안전하게 사용 가능하다.
      >
      > - 위에서 언급했던 것처럼 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하기에 다른 어떤 객체에서 참조하고 있을 수 있다. 이러한 부분에서 GC에서 Skip 대상이 되기에 GC의 성능을 높일 수 있다.

      

      >  **플라이웨이트 패턴 (Flyweight pattern) :** 데이터를 공유하여 메모리를 절약하는 패턴, 공통으로 사용되는 객체는 한번만 사용되고 Pool에의해서 관리, 사용된다.

    - 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하는 식으로 불필요한 객체 생성을 피할 수 있다.

    - 인스턴스 통제 가능하다.

      - 싱글턴, 인스턴스화 불가 =>가능하다.

  - 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.

    ```java
    public class Level {
      ...
      public static Level of(int score) {
        if (score < 50) {
          return new Basic();
        } else if (score < 80) {
          return new Intermediate();
        } else {
          return new Advanced();
        }
      }
      ...
    }
    ```

    - 반환할 객체의 클래스를 자유롭게 선택할 수 있는 "유연성"을 제공한다.

  - 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.

    - 반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관없다.

  - 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

- 단점
  - 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
    - 부모의 생성자로부터 Initialize해야하지만 없다면 불가능하다.
    - 하지만 상속보다 컴포지션을 사용하도록 유도하고 불변 타입으로 만들려면 이 제약을 지켜야 한다는 점에서 오히려 장점일 수도 있다.
  - 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.
    - 생성자처럼 API 설명에 명확히 드러나지 않으니 정적 팩터리 메서드 방식 클래스를 인스턴스화할 방법을 알아내야한다.

- 명명법
  - from
    - 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드
      - Date d = Date.from(instant)
  - of 
    - 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드
      - Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);
  - valueOf
    - from과 of의 더 자세한 버전
      - BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);
  - Instance || getInstance 
    - 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴임을 보장하지 않는다.
      - StackWalker luke = StackWalker.getInstance(options);
  - create || newInstance 
    - instance || getInstance와 같지만 매번 새로운 인스턴스를 생성해 반환함을 보장한다.
      - Object newArray = Array.newInstance(classObject, arrayLen);
  - getType 
    - getInstance와 같으나 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다.
      - FileStore fs = Files.getFileStore(path);
  - newType 
    - newInstance와 같으나 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다.
      - BufferedReader br = Files.newBufferedReader(path);
  - type 
    - getType과 newType의 간결한 버전
      - List litany = Collections.list(legacyLitany);

---

### 생성자에 매개변수가 많다면 빌더를 고려하라

- 점층적 생성자 패턴
  - 만들어진 생성자들 중 원하는 생성자 중 골라서 처리하면 된다.
  - 하지만 원하지 않는 매개변수 값을 지정해야 될 수 있다.
  - 또한 매개변수 개수가 많아지면 클라이언트 코드를 작성하거나 읽기 어렵다.
- 자바빈즈 패턴
  - 매개변수가 없는 생성자로 객체를 만든 후, 세터 메서드들을 호출해 세팅한다.
  - 객체 하나를 위해 메서드 여러 개를 호출해야 한다.
  - 완전히 생성되기 전까지는 일관성이 무너진 상태에 놓여있다.
  - 불변으로 만들 수 없다.
- 빌더 패턴
  - 필수 매개변수만으로 생성자를 호출해 빌더 객체를 얻고 빌더 객체가 제공하는 일종의 세터를 이용해 매개변수를 세팅한다.
  - 계층적으로 설계된 클래스와 함께 쓰이기 좋다.
  - 객체를 만들기 위해 빌더부터 만들어야 한다.
    - 성능에 민감한 상황에서는 문제가 될 수 있다.
  - 매개변수가 많은 상황에서 (4개 이상) 값어치를 한다.

---

### private 생성자나 열거 타입으로 싱글턴임을 보증하라

싱글턴 - 인스턴스를 오직 하나만 생성할 수 있는 클래스 ( ex) 함수와 같은 무상태 객체, 설계상 유일해야 하는 시스템 컴퍼넌트 )

싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워질 수 있다. ( mock 대체 불가능 )

​             

싱글턴 만드는 방법

- 생성자를 private으로 감춰두고 public static final을 통해 단 "하나"의 인스턴스를 초기화

  ```java
  public class Test {
  	public static final Test test = new Test();
  	private Test() { ... } // private 선언으로, 클래스 외부에서는 인스턴스 생성이 불가능하다.
  	
  	public void isExist() { ... }
  }
  ```

  

  - 리플렉션 API를 막기 위해 생성자를 수정하여 두번째 객체가 생성되려 할 때 예외를 Throw
  - 해당 클래스가 싱글턴임이 API에 명백히 드러난다.
  - 간결하다.

- 정적 팩터리 메서드를 public static 멤버로 제공

  ```java
  public class Test {
  	public static final Test test = new Test();
  	private Test() { ... }
  	public static Test getTest() { return test; }
  	
  	public void isExist() { ... }
  }
  ```

  

  - 이전과 달리 멤버를 private으로 닫고 팩터리 메서드로 제공
  - 항상 같은 객체의 참조(인스턴스)를 반환하므로 또 다른 인스턴스를 제공하지 않는다.
  - API를 바꾸지 않고도 싱글턴이 아니게 변경할 수 있다. 
  - 제네릭 싱글턴 팩터리로 만들 수 있다.
  - 정적 팩터리의 메서드 참조를 Supplier로 사용할 수 있다.
  - 직렬화를 위해 readResolve 메소드를 추가해야한다.

- Enum 타입으로 선언한다.

  ```java
  public enum Test {
  	INSTANCE;
  	
  	public void isExist() { ... }
  }
  ```

  - public 필드 방식과 비슷하지만 더 간결하고 추가 노력 없이 직렬화 할 수 있다.
  - 대부분 상황에서 가장 좋은 방법이다.



---

### 인스턴스화를 막으려거든 private 생성자를 사용하라



기본 타입 값이나 배열 관련 메서드들을 모아놓을 때

정적 메서드와 정적 필드만을 담은 클래스를 만들 때

객체를 생성해주는 정적 메서드(혹은 팩터리)를 모아놓을 때

final 클래스와 관련한 메서드들을 모아놓을 때



이러한 정적 멤버 혹은 메서드들을 모아놓은 유틸리티 클래스는 인스턴스로 만들어 쓰려고 설계한게 아니다.

추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다.

기본 생성자가 자동으로 생성되는 것을 막자.

```java
public class UtilityClass {
    // 기본 생성자가 만들어지는 것을 막는다(인스턴스화 방지용).
    private UtilityClass() {
        throw new AssertionError();
    }
    // 나머지 코드는 생략
}
```



- private한 생성자를 명시적으로 만들어 둔다.
- 클래스 안에서라도 생성자를 호출하지 않도록 Exeption을 던지는 것도 나쁘지 않은 선택이다.
- 생성자가 존재하는데 호출할 수 없는 부분이 존재하니 주석을 달아두자.
- 이 방법은 상속을 막는 방법으로도 사용되니 효과적이다.



---

### 불필요한 객체 생성을 피하라

똑같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재사용하는 편이 나을 때가 많다.

```java
// 새로운 객체 생성 (명시적으로 new 해주었으므로 새로운 객체로 생성)
String s1 = new String("binkini"); 

// 불변 클래스 => 재사용
String s2 = "bikini";
String s3 = "bikini"; 
```

- Boolean의 <mark>valueOf</mark>도 마찬가지이다.

​          

이를 위해 생성자 대신 정적 팩토리 메서드를 사용하자.

- 매번 같은 객체를 내줄 수 있다.

생성 비용이 아주 비싼 객체의 경우, 비싼 객체가 반복해서 필요하다면 캐싱하여 재사용하자.



```java
static boolean isRomanNumeral(String s) {
    return s.matches("%(?=.)M*(C[MD]|D?C{0, 3})"
                    +"(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
}
```

이 방식의 문제는 String.matches는 성능이 중요한 상황에서 반복해 사용하기에 적합하지 않다.

정규표현식용 Pattern 인스턴스는 한 번 쓰고 버려져서 바로 GC의 대상이 된다.

따라서, Pattern 인스턴스를 클래스 초기화 과정에서 직접 생성해 캐싱해두고 나중에 isRomanNumeral 메서드가 호출될 때마다 이 인스턴스를 재사용하면 된다.

```java
public class RomanNumerals {
	private static final Pattern ROMAN = Pattern.compile("%(?=.)M*(C[MD]|D?C{0, 3})"
                    +"(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");	
    static boolean isRomanNumeral(String s) {
        return ROMAN.matcher(s).matches();
    }
}
```

이는 성능뿐 아니라 코드도 더 명확해지는 효과를 일으킨다.

- 굳이 호출되지 않는다고 지연 초기화로 불필요한 초기화를 없앨 필요는 없다.
  - 코드가 복잡해지나 성능의 개선은 크지 않기 때문이다.

​          

어댑터 패턴 사용

- 실제 작업은 뒷단 객체에 위임하고, 자신은 제 2 인터페이스 역할을 해준다.
-  객체어댑터는 뒷단 객체만 관리한다.

Map의 KeySet 메서드

​	Map 객체안의 키를 전부 담은 Set 어댑터를 반환

```java
@DisplayName("keyset은 같은 Map을 바라본다")
@Test
void keyset(){
    Map<String, Object> test = new HashMap<>();
    javabom.put("Javabom", "Hello");

    Set<String> testSet1 = test.keySet();
    Set<String> testSet2 = test.keySet();

    Assertions.assertEquals(testSet1, testSet2);
}
```

​         

오토박싱

> 오토박싱이란, 기본타입을 자동으로 래퍼 클래스로 변환시켜주는 것을 말한다.
>
> 오토언박싱이란, 래퍼 클래스를 기본타입으로 변환시켜주는 것을 말한다.

기본타입과 그에 대응하는 박싱된 기본타입을 흐려주지만 완전히 없애주진 않는다.

```java
private static long sum(){
  Long sum = 0L;	
  for(long i =0; i <= Integer.MAX_VALUE; i++){
    sum += i;	// 불필요한 Long 인스턴스가 만들어진다.
  }
  return sum;
}
```

​         

본인만의 객체 풀을 만들지 말자.

굳이 객체 생성에 대한 부담감을 가져 객체 풀을 생성해 꺼내와서 만들려고 하지마라.

오히려 코드를 헷갈리게 만들고 메모리 사용량을 늘리고 성능을 떨어뜨린다.

JVM의 GC가 잘 최적화 되어있기에 가벼운 객체의 경우 객체 풀보다 훨씬 빠르다.



---

### 다 쓴 객체 참조를 해제하라

C, C++과 달리 GC가 메모리 관리를 알아서 해준다고 해도 메모리 관리에 더 이상 신경 쓰지 않아도 된다고 생각하면 안된다.

```java
// 코드 7-1 메모리 누수가 일어나는 위치는 어디인가? (36쪽)
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }

    public Object pop() {
        if (size == 0)
            throw new EmptyStackException();
        return elements[--size];
    }

    /**
     * 원소를 위한 공간을 적어도 하나 이상 확보한다.
     * 배열 크기를 늘려야 할 때마다 대략 두 배씩 늘린다.
     */
    private void ensureCapacity() {
        if (elements.length == size)
            elements = Arrays.copyOf(elements, 2 * size + 1);
    }

//    // 코드 7-2 제대로 구현한 pop 메서드 (37쪽)
//    public Object pop() {
//        if (size == 0)
//            throw new EmptyStackException();
//        Object result = elements[--size];
//        elements[size] = null; // 다 쓴 참조 해제
//        return result;
//    }

    public static void main(String[] args) {
        Stack stack = new Stack();
        for (String arg : args)
            stack.push(arg);

        while (true)
            System.err.println(stack.pop());
    }
}
```

- 위 부분에서 스택에서 size를 통해 늘렸다가 줄였다하는 모습을 확인할 수 있다.
- pop에서 elements는 pop된 객체의 참조를 아직 들고있기에 gc의 대상이 되지 못해 메모리에 계속 남아있다.
- 의도치 않게 객체 참조 하나를 살려두면 그 객체들이 참조하는 모든 객체를 살려두게 되어 최악의 경우 OutOfMemory가 될 수 있다.

- 따라서, 위 처럼 null로 해제해버리자.
- null로 해버리면 추후에 실수로 사용하려해도 NullPointerException을 발생시켜 사전에 방지할 수 있다.

​          

null 처리하는 일은 예외적인 경우여야 한다.

다 쓴 객체를 해제하는 가장 좋은 방법은 그 참조를 담은 변수를 유효 범위 밖으로 밀어내는 것이다.

스택은 자기 메모리를 직접 관리하는 클래스이기에 gc가 비활성 영역에서 참조하는 객체를 알아볼리 만무하다.

따라서, 이렇게 자기 메모리를 직접 관리하는 클래스라면 null 처리하여 항시 메모리 누수에 주의하자.

​       

객체 참조를 캐시에 넣고, 사용한 후에도 놔두는 경우 또한 신경써야한다.

- WeakHashMap을 사용해 캐시를 만들면 외부에서 키를 참조하는 동안만 엔트리가 살아있는 캐시가 된다.
- 캐시 엔트리의 유효 기간을 정확히 정의하기 어렵기에 ScheduledThreadPoolExcutor와 같은 백그라운드 스레드를 활용하거나 캐시에 새 엔트리를 추가할 때 부수 작업으로 수행하여 쓰지 않는 엔트리를 청소하자.

​       

리스너, 콜백

콜백을 등록만하고 해지하지 않는경우, 계속 쌓인다.

- 콜백을 약한 참조로 저장한다. (WeakHashMap의 키로 저장한다.)

---

### finalizer와 cleaner 사용을 피하라

자바는 두 가지 객체 소멸자를 제공한다.

- finalizer
  - 예측할 수 없고, 상황에 따라 위험할 수 있어 일반적으로 불필요하다.
  - 기본적으로 쓰지말아야한다.
  - 자바 9에서 deprecated되었다.
- cleaner
  - finalizer보다 덜 위험하지만, 여전히 예측할 수 없고, 느리고, 일반적으로 불필요하다.

자바에서는 try-with-resources, try-finally를 사용한다.

​          

finalizer와 cleaner는 즉시 수행된다는 보장이 없다.

- 실행되기까지 얼마나 걸릴지 알 수 없다.
- gc에 의해 조절되기에 최악의 상황을 가져올 수도 있다.

수행 여부도 보장하지 않는다.

- 상태를 영구적으로 수정하는 작업에서 절대 사용하지 마라.
- SYstem.gc나 System.runFinalization 메서드에 현혹되지 말자.
- *System.runFinalizerOnExit / Runtime.runFinalizerOnExit : 심각한 결함*

finalizer 동작중 발생한 예외가 무시되며, 처리할 작업이 남았어도 그 순간 종료된다.

- 잡지못한 예외로 객체가 마무리가 덜된 상태로 남아있을 수 있다 -. 훼손된 객체를 사용하려 할 때 예측할 수 없다.

심각한 성능 문제도 동반한다.

- try-with-resources => 12ns vs finalizer => 550ns

finalizer를 사용한 클래스는 finalizer 공격에 노출되어 심각한 보안 문제를 일으킬 수도 있다.

​         

하지만, finalizer와 cleaner에도 쓰임새가 존재한다.

- 자원의 소유자가 close() 메서드를 호출하지 않는 것에 대비한다.

  - 안전망 역할의 finalizer를 작성할때 그럴만한 값어치가 있는지 고민하자
  - 자바라이브러리 : FileInputStream, FileOutputStream, ThreadPoolExecutor

- 네이티브 피어

  - 일반 자바 객체가 네이티브 메서드를 통해 기능을 위임한 네이티브 객체자바 객체가 아니라 GC가 존재를 알지 못한다.

    성능 저하를 감당할 수 있고, 네이티브 피어가 심각한 자원을 갖고있지 않을 경우에 적당하다.즉시 회수해야한다면 .close()를 사용하자

---

### try-finally보다는 try-with-resources를 사용하라

자바 라이브러리에는 close 메서드를 호출해 직접 닫아줘야 하는 자원이 많다.

close에 대한 안전망으로 finalizer를 사용하고 있지만 그렇게 믿을만하지 못하다.

전통적으로 자원이 제대로 닫힘을 보장하는 수단으로 try-finally가 쓰였다.

- 코드 가독성에있어서 지저분하다.
- 두번째 예외가 첫번째 예외를 집어삼켜버려 실제 시스템에서 디버깅을 어렵게 한다.

​        

이를 해결하기 위해 try-with-resources를 사용하자.

- 이를 사용하기 위해서는 AutoCloseable 인터페이스를 구현해야한다.

  ```java
  public interface AutoCloseable {
      void close() throws Exception;
  }
  ```

  - close() 메서드 하나만 정의하였다.

```java
static void copy(String src, String dst) throws IOException {
  try (InputStream   in = new FileInputStream(src);
       OutputStream out = new FileOutputStream(dst)) {
    byte[] buf = new byte[BUFFER_SIZE];
    int n;
    while ((n = in.read(buf)) >= 0)
      out.write(buf, 0, n);
  } catch (IOException e) {
    return defaultVal;
  }
}
```

- 읽기 쉽고 문제 진단에 빠르다.
- catch를 이용해 try문을 중첩하지 않고도 다수의 예외 처리가 가능하다.
- 숨겨진 예외도 버려지지 않고, suppressed 꼬리표를 달고 출력된다.



---

### equals는 일반 규약을 지켜 재정의하라

equals는 재정의하기 쉬워보이지만 곳곳에 함정이 있다. 문제를 회피하는 가장 쉬운 길은 아예 재정의하지 않는 것이다.

1. 각 인스턴스가 본질적으로 고유하다.

   - 값을 표현하는 게 아니라 동작하는 개체를 표현하는 클래스가 해당된다.

   - Thread가 좋은 예로, Object의 equals 메서드는 이러한 클래스에 딱 맞게 구현되었다.
   - 아마 Repository, Service, Controller가 이 경우에 해당하지 않을까 싶다.
     - 값 표현 객체가 없을 경우

2. 인스턴스의 '논리적 동치성'을 검사할 일이 없다.

   - 논리적 동치성 검사 예시 : Pattern의 인스턴스가 같은 정규 표현식을 나타내는 지 검사

3.  상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어 맞는다.

   - Set, List, Map 구현체들

4. 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다.

​         

실수로라도 호출되는 걸 막고 싶다면 다음과 같이 하자.

```java
@Override public boolean equals (Object o){
  	throw new AssertionError();	// equals 호출 시 error();
}
```

그렇다면 equals를 재정의해야 할 때는 언제일까?

객체 식별성이 아니라 논리적 동치성을 확인해야하는데, 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때이다.

- 객체 식별성 -> 두 객체가 같은가, 같은 레퍼런스를 가지는가
- 논리적 동치성 -> 두 객체가 같은 값을 가지고 있는가.

equals가 논리적 동치성을 확인하도록 재정의해두면, 그 인스턴스는 값을 비교하길 원하는 프로그래머의 기대에 부응함은 물론이고 Map의 키와 Set의 원소로 사용할 수 있게 된다.

값 클래스라 해도, 값이 같은 인스턴스가 둘 이상 만들어지지 않음을 보장하는 인스턴스 통제 클래스라면 equals를 재정의하지 않아도 된다. 

- Enum, Static Factory Method Pattern
- 논리적으로 같은 인스턴스가 2개 이상 만들어지지 않으니 Object의 equals가 논리적 동치성까지 확인해준다.

​         

Equals 메서드의 규약

- 동치 클래스 : 집합을 서로 같은 원소들로 이루어진 부분집합으로 나누는 연산 
- equals 메서드가 쓸모 있으려면 모든 원소가 같은 동치류에 속한 어떤 원소와도 서로 교환이 가능해야 한다.



1. 반사성

   - null이 아닌 모든 참조 값 x에 대해 x.equals(x)는 true이다.
   - 객체는 자기 자신과 같아야한다.

2. 대칭성

   - null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)가 true이면 y.equals(x)도 true이다.
   - 두 객체는 서로에 대한 동치 여부에 대해 똑같이 답해야 한다.
   - equals 규약을 어기면 그 객체를 사용하는 다른 객체들이 어떻게 반응할지 알 수 없다.

   ```java
   public final class CaseInsensitiveString{
     private final String s;
     
     public CaseInsensitiveString(String s){
       this.s = Objects.requireNonNull(s);
     }
     
     @Override public boolean equals(Object o){
       if(o instanceof CaseInsensitiveString)
         return s.equalsIgnoreCase(((CaseInsensitiveString) o).s);
       if(o instanceof String) // 한방향으로만 작동한다.
         return s.equalsIgnoreCase((String) o);
       return false;
     }
   }
   
   CaseInsensitiveString cis = new CaseInsensitiveString("Polish");
   String s = "polish";
   
   cis.equals(s); // true
   s.equals(cis); // false
   ```

   ```java
   @Override public boolean equals(Object o){
     return o instanceof CaseInsensitiveString &&
       ((CaseInsensitiveString) o).s.equalsIgnoreCase(s); 
     // String에 대한 instanceof 부분을 빼고 구현한다.
   }
   ```

   - 애초에 String과도 연동하겠다는 생각을 버리자.

3. 추이성

   - null이 아닌 모든 참조 값 x, y, z에 대해 x.equals(y)가 true이고 y.equals(z)도 true이면, x.equals(z)도 true이다.
   - 삼단논법
   - 이 추이성 조건때문에 equals를 재정의하면 안되는 경우에 superclassㅇ서 equals를 정의한 경우를 언급했다.

   대칭성 위배

   ```java
   // ColorPoint.java 의 equals
   @Override public boolean equals(Object o){
     if(!(o instanceof ColorPoint))
       return false;
     return super.equals(o) && ((ColorPoint) o).color == color;
   }
   
   public static void main(){
     Point p = new Point(1,2);
     ColorPoint cp = new ColorPoint(1,2, Color.RED);
     p.equals(cp);	// true (Point의 equals로 계산)
     cp.equals(p);	// false (ColorPoint의 equals로 계산: color 필드 부분에서 false)
   }
   ```

   추이성 위배

   ```java
   //ColorPoint.java의 equals
   @Override public boolean equals(Obejct o){
     if(!(o instanceof Point))
       return false;
     if(!(o instanceof ColorPoint))
       return o.equals(this);
     return super.equals(o) && ((ColorPoint) o).color == color;
   }
   
   public static void main(){
     ColorPoint p1 = new ColorPoint(1,2, Color.RED);
     Point p2 = new Point(1,2);
     ColorPoint p3 = new ColorPoint(1,2, Color.BLUE);
     p1.equals(p2);	// true (ColorPoint의 equals 비교 //2번째 if문에서 Point의 equals로 변환)
     p2.equals(p3);	// true (Point의 equals 비교 // x,y 같으니 true)
     p1.equals(p3);	// false (ColorPoint의 equals 비교)
   }
   ```

   무한재귀

   ```java
   //SmellPoint.java의 equals
   @Override public boolean equals(Obejct o){
     if(!(o instanceof Point))
       return false;
     if(!(o instanceof SmellPoint))
       return o.equals(this);
     return super.equals(o) && ((SmellPoint) o).color == color;
   }
   
   public static void main(){
     ColorPoint p1 = new ColorPoint(1,2, Color.RED);
     SmellPoint p2 = new SmellPoint(1,2);
     p1.equals(p2);
     // 처음에 ColorPoint의 equals로 비교 : 2번째 if문 때문에 SmellPoint의 equals로 비교
     // 이후 SmellPoint의 equals로 비교 : 2번째 if문 때문에 ColorPoint의 equals로 비교
     // 무한 재귀의 상태!
   }
   ```

   이를 해결하기 위해 instanceof가 아니라 getClass로 검사를 하면 된다.

   ```java
   @Override public boolean equals(Object o){
     if(o == null || o.getClass() != getClass())
       return false;
     Point p = (Point) o;
     return p.x == x && p.y == y;
   }
   ```

   하지만 이는 근본적인 해결책이 아니다.

   리스코프 치환 원칙을 위배한다.

   - Point의 하위클래스는 정의상 여전히 Point이기 때문에 어디서든 Point로 활용되어야 한다.

   > 리스코프 치환원칙 (Liskov substitution principle) : 어떤 타입에 있어 중요한 속성이라면 그 하위 타입에서도 마찬가지로 중요하다. 따라서 그 타입의 모든 메서드가 하위 타입에서도 똑같이 잘 작동해야한다.
   >
   > Point의 하위클래스는 정의상 여전히 Point이므로 어디서든 Point로 활용가능해야한다.

​          

진짜 사용할 수 있는 방법

- 상속대신 컴포지션을 사용하자.

```java
public class ColorPoint{
  private final Point point;
  private final Color color;
 
  public Point asPoint(){ //view 메서드 패턴
    return point
  }
  
  @Override public boolean equals(Object o){
    if(!(o instanceof ColorPoint)){
      return false;
    }
    ColorPoint cp = (ColorPoin) o;
    return cp.point.equals(point) && cp.color.equals(color);
  }
}
```

ColorPoint - ColorPoint : ColorPoint의 equals를 이용하여 color 값까지 모두 비교

ColorPoint - Point : ColorPoint를 asPoint() 메소드를 이용해 Point로 바꾸어서, Point의 equlas를 이용해 x,y만 비교

Point - Point : Point의 equals를 이용하여 x,y 값 모두 비교

​          

- 추상 클래스의 하위클래스 사용하기
  - 추상클래스의 하위클래스에서는 equals 규약을 지키면서도 값을 추가할 수 있다.
  - 상위 클래스를 직접 인스턴스로 만드는게 불가능하기 때문에 하위클래스끼리의 비교가 가능해진다.

​       

일관성

- null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.

- 두 객체가 같다면 (어느 하나 혹은 두 객체 모두가 수정되지 않는한) 앞으로도 영원히 같아야한다.
  가변객체 = 비교 시점에 따라 서로 다를 수 있다.불변객체 = 한번 다르면 끝까지 달라야한다.

- equals는 항시 메모리에 존재하는 객체만을 사용한 결정적(deterministic) 계산만 수행해야한다.
  클래스가 불변이든 가변이든 equals의 판단에 신뢰할 수 없는 자원이 끼어들면 안된다 : ex URL과 매핑된 호스트의 IP 주소

​       

null 아님

- null이 아닌 모든 참조값 x에 대해, x.equals(null)은 false이다.

- 모든 객체가 null 과 같지 않아야한다.

```java
@Override public boolean equals(Object o){
  if( o == null){
    return false;
  }
}
```

```java
@Override public boolean equals(Obejct o){
  if(!(o instanceof MyType)) 	// instanceof 자체가 타입과 무관하게 null이면 false 반환함.
    return false;
  MyType mt = (MyType) o;
}
```



양질의 equals 메서드를 구현하는 4단계

- == 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다.
  - object identity를 검사한다.

- instanceof 연산자로 입력이 올바른 타입인지 확인한다.

- 올바른 타입의 경우 : equals가 정의된 클래스로 리턴이 되는가
- 올바른 타입이 아닌경우 ( == 구현한 특정 인터페이스) 
  - 구현한 (서로다른) 클래스간 비교가 가능하게 해야함
  - 이런 구현체들은 인터페이스의 equals를 이용하여 비교해야한다.

- 입력을 올바른 타입으로 형변환 한다.
  - 2번에서 instatnceof를 이용했기 때문에 100% 성공함

- 입력 객체와 자기 자신의 대응되는 '핵심' 필드들이 모두 일치하는지 하나씩 검사한다.
  - 2번에서 인터페이스를 사용했다면 입력의 필드값을 가져올 때도 인터페이스 메서드를 사용해야한다.

​            

기본타입과 참조타입

- 기본타입 : == 연산자 비교
  - float, double 필드 : Float.compare(float, float), Double.compare(double, double) 비교 (부동 소수 값으로 인해)
  - Float.equals(float)나 Double.equals(double) 은 오토 박싱을 수반할 수 있어 성능상 좋지 않다.
- 참조타입 : equals() 비교
- 배열 필드 : 원소 각각을 지침대로 비교한다. / 모두가 핵심 필드라면 Arrays.equals()를 사용한다.



 

null 정상값 취급 방지

- Object.equals(object, object) 로 비교하여 NullPointException 발생을 예방하자

 

필드의 표준형을 저장

- 비교하기 복잡한 필드는 필드의 표준형(canonical form)을 저장한후 비교 : 불변 클래스에 제격이다.

 

필드 비교 순서는 equals 성능을 좌우한다.

- 다를 가능성이 높은 필드 우선
- 비교 비용이 싼 필드 우선
- 핵심필드 / 파생필드 구분하자.

 

equals 재정의할 땐 hashCode도 반드시 재정의하자.

 

너무 복잡하게 해결하려 들지 말자.

 

Object 외의 타입을 매개변수로 받는 equals 메서드는 선언하지 말자.

```
public boolean equals(MyClass o) // @Override(재정의)가 아니라 다중정의 상태임!
```
