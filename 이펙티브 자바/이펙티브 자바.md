# 객체의 생성과 파괴

### 생성자 대신 정적 팩터리 메서드를 고려하라

정적 팩터리 메서드

```java
LocalTime openTime = LocalTime.of(9, 30);
```

- 그 클래스의 인스턴스를 반환하는 단순한 정적 메서드

- 장점

  - 이름을 가질 수 있다.

    - BigInteger vs BigInteger.probablePrime => 소수를 반환한다라는 의미는 후자가 더 잘 나타낸다.
    - 시그니처가 같은 생성자가 여러 개 필요할 것 같으면, 생성자를 정적 팩터리 메서드로 바꾸고 각각의 차이를 잘 드러내는 이름으로 지어주면 된다.

  - 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.

    ```java
    String str1 = "GSH";    //1. "GSH" 인스턴스를 생성
    String str2 = "GSH";    //2. 생성된 "GSH" 인스턴스를 재활용
    ```

    - 불변 클래스 같은 경우 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하고 있다.

      > 불변 클래스는 heap 영역에 생성되며 변경 불가능한 클래스이며 가변적이지 않는 클래스이다.
      >
      > - heap 영역에서 값 자체가 변경되는 것이 아니라, 대체되는 것이다. (방어적 복사-defensive-copy)
      >   - String a = "G"; a = "SH"; 라면 G가 SH로 바뀌는 것이 아니라 SH로 대체되는 것이다.
      >   - 단, StringBuffer는 가변 객체이다. 
      >
      > 불변 클래스에는 String, Boolean, Integer, Float, Long 등이 존재한다.
      >
      > 레퍼런스 타입의 객체이기 때문에된다.
      >
      >
      > 왜 사용해야 할까?
      >
      > - "불변"이기에 쓰기에 대한 큰 걱정이 없어 Thread-Safe하여 병렬 프로그래밍에 유용하며, 동기화를 고려하지 않아도 된다.
      >
      >   
      >
      > - "불변"이기에 Cache, Map, Set 등의 요소로 상당히 적합하다.
      >
      > - "불변"이기에 부수 효과의 가능성을 크게 줄일 수 있다.
      >
      > - "불변"이기에 안전하게 사용 가능하다.
      >
      > - 위에서 언급했던 것처럼 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하기에 다른 어떤 객체에서 참조하고 있을 수 있다. 이러한 부분에서 GC에서 Skip 대상이 되기에 GC의 성능을 높일 수 있다.

      

      >  **플라이웨이트 패턴 (Flyweight pattern) :** 데이터를 공유하여 메모리를 절약하는 패턴, 공통으로 사용되는 객체는 한번만 사용되고 Pool에의해서 관리, 사용된다.

    - 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하는 식으로 불필요한 객체 생성을 피할 수 있다.

    - 인스턴스 통제 가능하다.

      - 싱글턴, 인스턴스화 불가 =>가능하다.

  - 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.

    ```java
    public class Level {
      ...
      public static Level of(int score) {
        if (score < 50) {
          return new Basic();
        } else if (score < 80) {
          return new Intermediate();
        } else {
          return new Advanced();
        }
      }
      ...
    }
    ```

    - 반환할 객체의 클래스를 자유롭게 선택할 수 있는 "유연성"을 제공한다.

  - 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.

    - 반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관없다.

  - 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

- 단점
  - 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
    - 부모의 생성자로부터 Initialize해야하지만 없다면 불가능하다.
    - 하지만 상속보다 컴포지션을 사용하도록 유도하고 불변 타입으로 만들려면 이 제약을 지켜야 한다는 점에서 오히려 장점일 수도 있다.
  - 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.
    - 생성자처럼 API 설명에 명확히 드러나지 않으니 정적 팩터리 메서드 방식 클래스를 인스턴스화할 방법을 알아내야한다.

- 명명법
  - from
    - 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드
      - Date d = Date.from(instant)
  - of 
    - 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드
      - Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);
  - valueOf
    - from과 of의 더 자세한 버전
      - BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);
  - Instance || getInstance 
    - 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴임을 보장하지 않는다.
      - StackWalker luke = StackWalker.getInstance(options);
  - create || newInstance 
    - instance || getInstance와 같지만 매번 새로운 인스턴스를 생성해 반환함을 보장한다.
      - Object newArray = Array.newInstance(classObject, arrayLen);
  - getType 
    - getInstance와 같으나 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다.
      - FileStore fs = Files.getFileStore(path);
  - newType 
    - newInstance와 같으나 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다.
      - BufferedReader br = Files.newBufferedReader(path);
  - type 
    - getType과 newType의 간결한 버전
      - List litany = Collections.list(legacyLitany);

---

### 생성자에 매개변수가 많다면 빌더를 고려하라

- 점층적 생성자 패턴
  - 만들어진 생성자들 중 원하는 생성자 중 골라서 처리하면 된다.
  - 하지만 원하지 않는 매개변수 값을 지정해야 될 수 있다.
  - 또한 매개변수 개수가 많아지면 클라이언트 코드를 작성하거나 읽기 어렵다.
- 자바빈즈 패턴
  - 매개변수가 없는 생성자로 객체를 만든 후, 세터 메서드들을 호출해 세팅한다.
  - 객체 하나를 위해 메서드 여러 개를 호출해야 한다.
  - 완전히 생성되기 전까지는 일관성이 무너진 상태에 놓여있다.
  - 불변으로 만들 수 없다.
- 빌더 패턴
  - 필수 매개변수만으로 생성자를 호출해 빌더 객체를 얻고 빌더 객체가 제공하는 일종의 세터를 이용해 매개변수를 세팅한다.
  - 계층적으로 설계된 클래스와 함께 쓰이기 좋다.
  - 객체를 만들기 위해 빌더부터 만들어야 한다.
    - 성능에 민감한 상황에서는 문제가 될 수 있다.
  - 매개변수가 많은 상황에서 (4개 이상) 값어치를 한다.

---

### private 생성자나 열거 타입으로 싱글턴임을 보증하라

싱글턴 - 인스턴스를 오직 하나만 생성할 수 있는 클래스 ( ex) 함수와 같은 무상태 객체, 설계상 유일해야 하는 시스템 컴퍼넌트 )

싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워질 수 있다. ( mock 대체 불가능 )

​             

싱글턴 만드는 방법

- 생성자를 private으로 감춰두고 public static final을 통해 단 "하나"의 인스턴스를 초기화

  ```java
  public class Test {
  	public static final Test test = new Test();
  	private Test() { ... } // private 선언으로, 클래스 외부에서는 인스턴스 생성이 불가능하다.
  	
  	public void isExist() { ... }
  }
  ```

  

  - 리플렉션 API를 막기 위해 생성자를 수정하여 두번째 객체가 생성되려 할 때 예외를 Throw
  - 해당 클래스가 싱글턴임이 API에 명백히 드러난다.
  - 간결하다.

- 정적 팩터리 메서드를 public static 멤버로 제공

  ```java
  public class Test {
  	public static final Test test = new Test();
  	private Test() { ... }
  	public static Test getTest() { return test; }
  	
  	public void isExist() { ... }
  }
  ```

  

  - 이전과 달리 멤버를 private으로 닫고 팩터리 메서드로 제공
  - 항상 같은 객체의 참조(인스턴스)를 반환하므로 또 다른 인스턴스를 제공하지 않는다.
  - API를 바꾸지 않고도 싱글턴이 아니게 변경할 수 있다. 
  - 제네릭 싱글턴 팩터리로 만들 수 있다.
  - 정적 팩터리의 메서드 참조를 Supplier로 사용할 수 있다.
  - 직렬화를 위해 readResolve 메소드를 추가해야한다.

- Enum 타입으로 선언한다.

  ```java
  public enum Test {
  	INSTANCE;
  	
  	public void isExist() { ... }
  }
  ```

  - public 필드 방식과 비슷하지만 더 간결하고 추가 노력 없이 직렬화 할 수 있다.
  - 대부분 상황에서 가장 좋은 방법이다.



---

### 인스턴스화를 막으려거든 private 생성자를 사용하라



기본 타입 값이나 배열 관련 메서드들을 모아놓을 때

정적 메서드와 정적 필드만을 담은 클래스를 만들 때

객체를 생성해주는 정적 메서드(혹은 팩터리)를 모아놓을 때

final 클래스와 관련한 메서드들을 모아놓을 때



이러한 정적 멤버 혹은 메서드들을 모아놓은 유틸리티 클래스는 인스턴스로 만들어 쓰려고 설계한게 아니다.

추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다.

기본 생성자가 자동으로 생성되는 것을 막자.

```java
public class UtilityClass {
    // 기본 생성자가 만들어지는 것을 막는다(인스턴스화 방지용).
    private UtilityClass() {
        throw new AssertionError();
    }
    // 나머지 코드는 생략
}
```



- private한 생성자를 명시적으로 만들어 둔다.
- 클래스 안에서라도 생성자를 호출하지 않도록 Exeption을 던지는 것도 나쁘지 않은 선택이다.
- 생성자가 존재하는데 호출할 수 없는 부분이 존재하니 주석을 달아두자.
- 이 방법은 상속을 막는 방법으로도 사용되니 효과적이다.
