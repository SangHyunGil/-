# 객체의 생성과 파괴

### 생성자 대신 정적 팩터리 메서드를 고려하라

정적 팩터리 메서드

```java
LocalTime openTime = LocalTime.of(9, 30);
```

- 그 클래스의 인스턴스를 반환하는 단순한 정적 메서드

- 장점

  - 이름을 가질 수 있다.

    - BigInteger vs BigInteger.probablePrime => 소수를 반환한다라는 의미는 후자가 더 잘 나타낸다.
    - 시그니처가 같은 생성자가 여러 개 필요할 것 같으면, 생성자를 정적 팩터리 메서드로 바꾸고 각각의 차이를 잘 드러내는 이름으로 지어주면 된다.

  - 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.

    ```java
    String str1 = "GSH";    //1. "GSH" 인스턴스를 생성
    String str2 = "GSH";    //2. 생성된 "GSH" 인스턴스를 재활용
    ```

    - 불변 클래스 같은 경우 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하고 있다.

      > 불변 클래스는 heap 영역에 생성되며 변경 불가능한 클래스이며 가변적이지 않는 클래스이다.
      >
      > - heap 영역에서 값 자체가 변경되는 것이 아니라, 대체되는 것이다. (방어적 복사-defensive-copy)
      >   - String a = "G"; a = "SH"; 라면 G가 SH로 바뀌는 것이 아니라 SH로 대체되는 것이다.
      >   - 단, StringBuffer는 가변 객체이다. 
      >
      > 불변 클래스에는 String, Boolean, Integer, Float, Long 등이 존재한다.
      >
      > 레퍼런스 타입의 객체이기 때문에된다.
      >
      >
      > 왜 사용해야 할까?
      >
      > - "불변"이기에 쓰기에 대한 큰 걱정이 없어 Thread-Safe하여 병렬 프로그래밍에 유용하며, 동기화를 고려하지 않아도 된다.
      >
      >   
      >
      > - "불변"이기에 Cache, Map, Set 등의 요소로 상당히 적합하다.
      >
      > - "불변"이기에 부수 효과의 가능성을 크게 줄일 수 있다.
      >
      > - "불변"이기에 안전하게 사용 가능하다.
      >
      > - 위에서 언급했던 것처럼 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하기에 다른 어떤 객체에서 참조하고 있을 수 있다. 이러한 부분에서 GC에서 Skip 대상이 되기에 GC의 성능을 높일 수 있다.

      

      >  **플라이웨이트 패턴 (Flyweight pattern) :** 데이터를 공유하여 메모리를 절약하는 패턴, 공통으로 사용되는 객체는 한번만 사용되고 Pool에의해서 관리, 사용된다.

    - 인스턴스를 미리 만들어 놓거나 새로 생성한 인스턴스를 캐싱하여 재활용하는 식으로 불필요한 객체 생성을 피할 수 있다.

    - 인스턴스 통제 가능하다.

      - 싱글턴, 인스턴스화 불가 =>가능하다.

  - 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.

    ```java
    public class Level {
      ...
      public static Level of(int score) {
        if (score < 50) {
          return new Basic();
        } else if (score < 80) {
          return new Intermediate();
        } else {
          return new Advanced();
        }
      }
      ...
    }
    ```

    - 반환할 객체의 클래스를 자유롭게 선택할 수 있는 "유연성"을 제공한다.

  - 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.

    - 반환 타입의 하위 타입이기만 하면 어떤 클래스의 객체를 반환하든 상관없다.

  - 정적 팩터리 메서드를 작성하는 시점에는 반환할 객체의 클래스가 존재하지 않아도 된다.

- 단점
  - 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
    - 부모의 생성자로부터 Initialize해야하지만 없다면 불가능하다.
    - 하지만 상속보다 컴포지션을 사용하도록 유도하고 불변 타입으로 만들려면 이 제약을 지켜야 한다는 점에서 오히려 장점일 수도 있다.
  - 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.
    - 생성자처럼 API 설명에 명확히 드러나지 않으니 정적 팩터리 메서드 방식 클래스를 인스턴스화할 방법을 알아내야한다.

- 명명법
  - from
    - 매개변수를 하나 받아서 해당 타입의 인스턴스를 반환하는 형변환 메서드
      - Date d = Date.from(instant)
  - of 
    - 여러 매개변수를 받아 적합한 타입의 인스턴스를 반환하는 집계 메서드
      - Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);
  - valueOf
    - from과 of의 더 자세한 버전
      - BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);
  - Instance || getInstance 
    - 매개변수로 명시한 인스턴스를 반환하지만, 같은 인스턴임을 보장하지 않는다.
      - StackWalker luke = StackWalker.getInstance(options);
  - create || newInstance 
    - instance || getInstance와 같지만 매번 새로운 인스턴스를 생성해 반환함을 보장한다.
      - Object newArray = Array.newInstance(classObject, arrayLen);
  - getType 
    - getInstance와 같으나 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다.
      - FileStore fs = Files.getFileStore(path);
  - newType 
    - newInstance와 같으나 생성할 클래스가 아닌 다른 클래스에 팩터리 메서드를 정의할 때 쓴다.
      - BufferedReader br = Files.newBufferedReader(path);
  - type 
    - getType과 newType의 간결한 버전
      - List litany = Collections.list(legacyLitany);

---

### 생성자에 매개변수가 많다면 빌더를 고려하라

- 점층적 생성자 패턴
  - 만들어진 생성자들 중 원하는 생성자 중 골라서 처리하면 된다.
  - 하지만 원하지 않는 매개변수 값을 지정해야 될 수 있다.
  - 또한 매개변수 개수가 많아지면 클라이언트 코드를 작성하거나 읽기 어렵다.
- 자바빈즈 패턴
  - 매개변수가 없는 생성자로 객체를 만든 후, 세터 메서드들을 호출해 세팅한다.
  - 객체 하나를 위해 메서드 여러 개를 호출해야 한다.
  - 완전히 생성되기 전까지는 일관성이 무너진 상태에 놓여있다.
  - 불변으로 만들 수 없다.
- 빌더 패턴
  - 필수 매개변수만으로 생성자를 호출해 빌더 객체를 얻고 빌더 객체가 제공하는 일종의 세터를 이용해 매개변수를 세팅한다.
  - 계층적으로 설계된 클래스와 함께 쓰이기 좋다.
  - 객체를 만들기 위해 빌더부터 만들어야 한다.
    - 성능에 민감한 상황에서는 문제가 될 수 있다.
  - 매개변수가 많은 상황에서 (4개 이상) 값어치를 한다.

---

### private 생성자나 열거 타입으로 싱글턴임을 보증하라

싱글턴 - 인스턴스를 오직 하나만 생성할 수 있는 클래스 ( ex) 함수와 같은 무상태 객체, 설계상 유일해야 하는 시스템 컴퍼넌트 )

싱글턴으로 만들면 이를 사용하는 클라이언트를 테스트하기가 어려워질 수 있다. ( mock 대체 불가능 )

​             

싱글턴 만드는 방법

- 생성자를 private으로 감춰두고 public static final을 통해 단 "하나"의 인스턴스를 초기화

  ```java
  public class Test {
  	public static final Test test = new Test();
  	private Test() { ... } // private 선언으로, 클래스 외부에서는 인스턴스 생성이 불가능하다.
  	
  	public void isExist() { ... }
  }
  ```

  

  - 리플렉션 API를 막기 위해 생성자를 수정하여 두번째 객체가 생성되려 할 때 예외를 Throw
  - 해당 클래스가 싱글턴임이 API에 명백히 드러난다.
  - 간결하다.

- 정적 팩터리 메서드를 public static 멤버로 제공

  ```java
  public class Test {
  	public static final Test test = new Test();
  	private Test() { ... }
  	public static Test getTest() { return test; }
  	
  	public void isExist() { ... }
  }
  ```

  

  - 이전과 달리 멤버를 private으로 닫고 팩터리 메서드로 제공
  - 항상 같은 객체의 참조(인스턴스)를 반환하므로 또 다른 인스턴스를 제공하지 않는다.
  - API를 바꾸지 않고도 싱글턴이 아니게 변경할 수 있다. 
  - 제네릭 싱글턴 팩터리로 만들 수 있다.
  - 정적 팩터리의 메서드 참조를 Supplier로 사용할 수 있다.
  - 직렬화를 위해 readResolve 메소드를 추가해야한다.

- Enum 타입으로 선언한다.

  ```java
  public enum Test {
  	INSTANCE;
  	
  	public void isExist() { ... }
  }
  ```

  - public 필드 방식과 비슷하지만 더 간결하고 추가 노력 없이 직렬화 할 수 있다.
  - 대부분 상황에서 가장 좋은 방법이다.



---

### 인스턴스화를 막으려거든 private 생성자를 사용하라



기본 타입 값이나 배열 관련 메서드들을 모아놓을 때

정적 메서드와 정적 필드만을 담은 클래스를 만들 때

객체를 생성해주는 정적 메서드(혹은 팩터리)를 모아놓을 때

final 클래스와 관련한 메서드들을 모아놓을 때



이러한 정적 멤버 혹은 메서드들을 모아놓은 유틸리티 클래스는 인스턴스로 만들어 쓰려고 설계한게 아니다.

추상 클래스로 만드는 것으로는 인스턴스화를 막을 수 없다.

기본 생성자가 자동으로 생성되는 것을 막자.

```java
public class UtilityClass {
    // 기본 생성자가 만들어지는 것을 막는다(인스턴스화 방지용).
    private UtilityClass() {
        throw new AssertionError();
    }
    // 나머지 코드는 생략
}
```



- private한 생성자를 명시적으로 만들어 둔다.
- 클래스 안에서라도 생성자를 호출하지 않도록 Exeption을 던지는 것도 나쁘지 않은 선택이다.
- 생성자가 존재하는데 호출할 수 없는 부분이 존재하니 주석을 달아두자.
- 이 방법은 상속을 막는 방법으로도 사용되니 효과적이다.



---

### 불필요한 객체 생성을 피하라

똑같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재사용하는 편이 나을 때가 많다.

```java
// 새로운 객체 생성 (명시적으로 new 해주었으므로 새로운 객체로 생성)
String s1 = new String("binkini"); 

// 불변 클래스 => 재사용
String s2 = "bikini";
String s3 = "bikini"; 
```

- Boolean의 <mark>valueOf</mark>도 마찬가지이다.

​          

이를 위해 생성자 대신 정적 팩토리 메서드를 사용하자.

- 매번 같은 객체를 내줄 수 있다.

생성 비용이 아주 비싼 객체의 경우, 비싼 객체가 반복해서 필요하다면 캐싱하여 재사용하자.



```java
static boolean isRomanNumeral(String s) {
    return s.matches("%(?=.)M*(C[MD]|D?C{0, 3})"
                    +"(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");
}
```

이 방식의 문제는 String.matches는 성능이 중요한 상황에서 반복해 사용하기에 적합하지 않다.

정규표현식용 Pattern 인스턴스는 한 번 쓰고 버려져서 바로 GC의 대상이 된다.

따라서, Pattern 인스턴스를 클래스 초기화 과정에서 직접 생성해 캐싱해두고 나중에 isRomanNumeral 메서드가 호출될 때마다 이 인스턴스를 재사용하면 된다.

```java
public class RomanNumerals {
	private static final Pattern ROMAN = Pattern.compile("%(?=.)M*(C[MD]|D?C{0, 3})"
                    +"(X[CL]|L?X{0,3})(I[XV]|V?I{0,3})$");	
    static boolean isRomanNumeral(String s) {
        return ROMAN.matcher(s).matches();
    }
}
```

이는 성능뿐 아니라 코드도 더 명확해지는 효과를 일으킨다.

- 굳이 호출되지 않는다고 지연 초기화로 불필요한 초기화를 없앨 필요는 없다.
  - 코드가 복잡해지나 성능의 개선은 크지 않기 때문이다.

​          

어댑터 패턴 사용

- 실제 작업은 뒷단 객체에 위임하고, 자신은 제 2 인터페이스 역할을 해준다.
-  객체어댑터는 뒷단 객체만 관리한다.

Map의 KeySet 메서드

​	Map 객체안의 키를 전부 담은 Set 어댑터를 반환

```java
@DisplayName("keyset은 같은 Map을 바라본다")
@Test
void keyset(){
    Map<String, Object> test = new HashMap<>();
    javabom.put("Javabom", "Hello");

    Set<String> testSet1 = test.keySet();
    Set<String> testSet2 = test.keySet();

    Assertions.assertEquals(testSet1, testSet2);
}
```

​         

오토박싱

> 오토박싱이란, 기본타입을 자동으로 래퍼 클래스로 변환시켜주는 것을 말한다.
>
> 오토언박싱이란, 래퍼 클래스를 기본타입으로 변환시켜주는 것을 말한다.

기본타입과 그에 대응하는 박싱된 기본타입을 흐려주지만 완전히 없애주진 않는다.

```java
private static long sum(){
  Long sum = 0L;	
  for(long i =0; i <= Integer.MAX_VALUE; i++){
    sum += i;	// 불필요한 Long 인스턴스가 만들어진다.
  }
  return sum;
}
```

​         

본인만의 객체 풀을 만들지 말자.

굳이 객체 생성에 대한 부담감을 가져 객체 풀을 생성해 꺼내와서 만들려고 하지마라.

오히려 코드를 헷갈리게 만들고 메모리 사용량을 늘리고 성능을 떨어뜨린다.

JVM의 GC가 잘 최적화 되어있기에 가벼운 객체의 경우 객체 풀보다 훨씬 빠르다.



---

### 다 쓴 객체 참조를 해제하라

C, C++과 달리 GC가 메모리 관리를 알아서 해준다고 해도 메모리 관리에 더 이상 신경 쓰지 않아도 된다고 생각하면 안된다.

```java
// 코드 7-1 메모리 누수가 일어나는 위치는 어디인가? (36쪽)
public class Stack {
    private Object[] elements;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(Object e) {
        ensureCapacity();
        elements[size++] = e;
    }

    public Object pop() {
        if (size == 0)
            throw new EmptyStackException();
        return elements[--size];
    }

    /**
     * 원소를 위한 공간을 적어도 하나 이상 확보한다.
     * 배열 크기를 늘려야 할 때마다 대략 두 배씩 늘린다.
     */
    private void ensureCapacity() {
        if (elements.length == size)
            elements = Arrays.copyOf(elements, 2 * size + 1);
    }

//    // 코드 7-2 제대로 구현한 pop 메서드 (37쪽)
//    public Object pop() {
//        if (size == 0)
//            throw new EmptyStackException();
//        Object result = elements[--size];
//        elements[size] = null; // 다 쓴 참조 해제
//        return result;
//    }

    public static void main(String[] args) {
        Stack stack = new Stack();
        for (String arg : args)
            stack.push(arg);

        while (true)
            System.err.println(stack.pop());
    }
}
```

- 위 부분에서 스택에서 size를 통해 늘렸다가 줄였다하는 모습을 확인할 수 있다.
- pop에서 elements는 pop된 객체의 참조를 아직 들고있기에 gc의 대상이 되지 못해 메모리에 계속 남아있다.
- 의도치 않게 객체 참조 하나를 살려두면 그 객체들이 참조하는 모든 객체를 살려두게 되어 최악의 경우 OutOfMemory가 될 수 있다.

- 따라서, 위 처럼 null로 해제해버리자.
- null로 해버리면 추후에 실수로 사용하려해도 NullPointerException을 발생시켜 사전에 방지할 수 있다.

​          

null 처리하는 일은 예외적인 경우여야 한다.

다 쓴 객체를 해제하는 가장 좋은 방법은 그 참조를 담은 변수를 유효 범위 밖으로 밀어내는 것이다.

스택은 자기 메모리를 직접 관리하는 클래스이기에 gc가 비활성 영역에서 참조하는 객체를 알아볼리 만무하다.

따라서, 이렇게 자기 메모리를 직접 관리하는 클래스라면 null 처리하여 항시 메모리 누수에 주의하자.

​       

객체 참조를 캐시에 넣고, 사용한 후에도 놔두는 경우 또한 신경써야한다.

- WeakHashMap을 사용해 캐시를 만들면 외부에서 키를 참조하는 동안만 엔트리가 살아있는 캐시가 된다.
- 캐시 엔트리의 유효 기간을 정확히 정의하기 어렵기에 ScheduledThreadPoolExcutor와 같은 백그라운드 스레드를 활용하거나 캐시에 새 엔트리를 추가할 때 부수 작업으로 수행하여 쓰지 않는 엔트리를 청소하자.

​       

리스너, 콜백

콜백을 등록만하고 해지하지 않는경우, 계속 쌓인다.

- 콜백을 약한 참조로 저장한다. (WeakHashMap의 키로 저장한다.)

---

### finalizer와 cleaner 사용을 피하라

자바는 두 가지 객체 소멸자를 제공한다.

- finalizer
  - 예측할 수 없고, 상황에 따라 위험할 수 있어 일반적으로 불필요하다.
  - 기본적으로 쓰지말아야한다.
  - 자바 9에서 deprecated되었다.
- cleaner
  - finalizer보다 덜 위험하지만, 여전히 예측할 수 없고, 느리고, 일반적으로 불필요하다.

자바에서는 try-with-resources, try-finally를 사용한다.

​          

finalizer와 cleaner는 즉시 수행된다는 보장이 없다.

- 실행되기까지 얼마나 걸릴지 알 수 없다.
- gc에 의해 조절되기에 최악의 상황을 가져올 수도 있다.

수행 여부도 보장하지 않는다.

- 상태를 영구적으로 수정하는 작업에서 절대 사용하지 마라.
- SYstem.gc나 System.runFinalization 메서드에 현혹되지 말자.
- *System.runFinalizerOnExit / Runtime.runFinalizerOnExit : 심각한 결함*

finalizer 동작중 발생한 예외가 무시되며, 처리할 작업이 남았어도 그 순간 종료된다.

- 잡지못한 예외로 객체가 마무리가 덜된 상태로 남아있을 수 있다 -. 훼손된 객체를 사용하려 할 때 예측할 수 없다.

심각한 성능 문제도 동반한다.

- try-with-resources => 12ns vs finalizer => 550ns

finalizer를 사용한 클래스는 finalizer 공격에 노출되어 심각한 보안 문제를 일으킬 수도 있다.

​         

하지만, finalizer와 cleaner에도 쓰임새가 존재한다.

- 자원의 소유자가 close() 메서드를 호출하지 않는 것에 대비한다.

  - 안전망 역할의 finalizer를 작성할때 그럴만한 값어치가 있는지 고민하자
  - 자바라이브러리 : FileInputStream, FileOutputStream, ThreadPoolExecutor

- 네이티브 피어

  - 일반 자바 객체가 네이티브 메서드를 통해 기능을 위임한 네이티브 객체자바 객체가 아니라 GC가 존재를 알지 못한다.

    성능 저하를 감당할 수 있고, 네이티브 피어가 심각한 자원을 갖고있지 않을 경우에 적당하다.즉시 회수해야한다면 .close()를 사용하자

---

### try-finally보다는 try-with-resources를 사용하라

자바 라이브러리에는 close 메서드를 호출해 직접 닫아줘야 하는 자원이 많다.

close에 대한 안전망으로 finalizer를 사용하고 있지만 그렇게 믿을만하지 못하다.

전통적으로 자원이 제대로 닫힘을 보장하는 수단으로 try-finally가 쓰였다.

- 코드 가독성에있어서 지저분하다.
- 두번째 예외가 첫번째 예외를 집어삼켜버려 실제 시스템에서 디버깅을 어렵게 한다.

​        

이를 해결하기 위해 try-with-resources를 사용하자.

- 이를 사용하기 위해서는 AutoCloseable 인터페이스를 구현해야한다.

  ```java
  public interface AutoCloseable {
      void close() throws Exception;
  }
  ```

  - close() 메서드 하나만 정의하였다.

```java
static void copy(String src, String dst) throws IOException {
  try (InputStream   in = new FileInputStream(src);
       OutputStream out = new FileOutputStream(dst)) {
    byte[] buf = new byte[BUFFER_SIZE];
    int n;
    while ((n = in.read(buf)) >= 0)
      out.write(buf, 0, n);
  } catch (IOException e) {
    return defaultVal;
  }
}
```

- 읽기 쉽고 문제 진단에 빠르다.
- catch를 이용해 try문을 중첩하지 않고도 다수의 예외 처리가 가능하다.
- 숨겨진 예외도 버려지지 않고, suppressed 꼬리표를 달고 출력된다.



---

### equals는 일반 규약을 지켜 재정의하라

equals는 재정의하기 쉬워보이지만 곳곳에 함정이 있다. 문제를 회피하는 가장 쉬운 길은 아예 재정의하지 않는 것이다.

1. 각 인스턴스가 본질적으로 고유하다.

   - 값을 표현하는 게 아니라 동작하는 개체를 표현하는 클래스가 해당된다.

   - Thread가 좋은 예로, Object의 equals 메서드는 이러한 클래스에 딱 맞게 구현되었다.
   - 아마 Repository, Service, Controller가 이 경우에 해당하지 않을까 싶다.
     - 값 표현 객체가 없을 경우

2. 인스턴스의 '논리적 동치성'을 검사할 일이 없다.

   - 논리적 동치성 검사 예시 : Pattern의 인스턴스가 같은 정규 표현식을 나타내는 지 검사

3.  상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어 맞는다.

   - Set, List, Map 구현체들

4. 클래스가 private이거나 package-private이고 equals 메서드를 호출할 일이 없다.

​         

실수로라도 호출되는 걸 막고 싶다면 다음과 같이 하자.

```java
@Override public boolean equals (Object o){
  	throw new AssertionError();	// equals 호출 시 error();
}
```

그렇다면 equals를 재정의해야 할 때는 언제일까?

객체 식별성이 아니라 논리적 동치성을 확인해야하는데, 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때이다.

- 객체 식별성 -> 두 객체가 같은가, 같은 레퍼런스를 가지는가
- 논리적 동치성 -> 두 객체가 같은 값을 가지고 있는가.

equals가 논리적 동치성을 확인하도록 재정의해두면, 그 인스턴스는 값을 비교하길 원하는 프로그래머의 기대에 부응함은 물론이고 Map의 키와 Set의 원소로 사용할 수 있게 된다.

값 클래스라 해도, 값이 같은 인스턴스가 둘 이상 만들어지지 않음을 보장하는 인스턴스 통제 클래스라면 equals를 재정의하지 않아도 된다. 

- Enum, Static Factory Method Pattern
- 논리적으로 같은 인스턴스가 2개 이상 만들어지지 않으니 Object의 equals가 논리적 동치성까지 확인해준다.

​         

Equals 메서드의 규약

- 동치 클래스 : 집합을 서로 같은 원소들로 이루어진 부분집합으로 나누는 연산 
- equals 메서드가 쓸모 있으려면 모든 원소가 같은 동치류에 속한 어떤 원소와도 서로 교환이 가능해야 한다.



1. 반사성

   - null이 아닌 모든 참조 값 x에 대해 x.equals(x)는 true이다.
   - 객체는 자기 자신과 같아야한다.

2. 대칭성

   - null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)가 true이면 y.equals(x)도 true이다.
   - 두 객체는 서로에 대한 동치 여부에 대해 똑같이 답해야 한다.
   - equals 규약을 어기면 그 객체를 사용하는 다른 객체들이 어떻게 반응할지 알 수 없다.

   ```java
   public final class CaseInsensitiveString{
     private final String s;
     
     public CaseInsensitiveString(String s){
       this.s = Objects.requireNonNull(s);
     }
     
     @Override public boolean equals(Object o){
       if(o instanceof CaseInsensitiveString)
         return s.equalsIgnoreCase(((CaseInsensitiveString) o).s);
       if(o instanceof String) // 한방향으로만 작동한다.
         return s.equalsIgnoreCase((String) o);
       return false;
     }
   }
   
   CaseInsensitiveString cis = new CaseInsensitiveString("Polish");
   String s = "polish";
   
   cis.equals(s); // true
   s.equals(cis); // false
   ```

   ```java
   @Override public boolean equals(Object o){
     return o instanceof CaseInsensitiveString &&
       ((CaseInsensitiveString) o).s.equalsIgnoreCase(s); 
     // String에 대한 instanceof 부분을 빼고 구현한다.
   }
   ```

   - 애초에 String과도 연동하겠다는 생각을 버리자.

3. 추이성

   - null이 아닌 모든 참조 값 x, y, z에 대해 x.equals(y)가 true이고 y.equals(z)도 true이면, x.equals(z)도 true이다.
   - 삼단논법
   - 이 추이성 조건때문에 equals를 재정의하면 안되는 경우에 superclassㅇ서 equals를 정의한 경우를 언급했다.

   대칭성 위배

   ```java
   // ColorPoint.java 의 equals
   @Override public boolean equals(Object o){
     if(!(o instanceof ColorPoint))
       return false;
     return super.equals(o) && ((ColorPoint) o).color == color;
   }
   
   public static void main(){
     Point p = new Point(1,2);
     ColorPoint cp = new ColorPoint(1,2, Color.RED);
     p.equals(cp);	// true (Point의 equals로 계산)
     cp.equals(p);	// false (ColorPoint의 equals로 계산: color 필드 부분에서 false)
   }
   ```

   추이성 위배

   ```java
   //ColorPoint.java의 equals
   @Override public boolean equals(Obejct o){
     if(!(o instanceof Point))
       return false;
     if(!(o instanceof ColorPoint))
       return o.equals(this);
     return super.equals(o) && ((ColorPoint) o).color == color;
   }
   
   public static void main(){
     ColorPoint p1 = new ColorPoint(1,2, Color.RED);
     Point p2 = new Point(1,2);
     ColorPoint p3 = new ColorPoint(1,2, Color.BLUE);
     p1.equals(p2);	// true (ColorPoint의 equals 비교 //2번째 if문에서 Point의 equals로 변환)
     p2.equals(p3);	// true (Point의 equals 비교 // x,y 같으니 true)
     p1.equals(p3);	// false (ColorPoint의 equals 비교)
   }
   ```

   무한재귀

   ```java
   //SmellPoint.java의 equals
   @Override public boolean equals(Obejct o){
     if(!(o instanceof Point))
       return false;
     if(!(o instanceof SmellPoint))
       return o.equals(this);
     return super.equals(o) && ((SmellPoint) o).color == color;
   }
   
   public static void main(){
     ColorPoint p1 = new ColorPoint(1,2, Color.RED);
     SmellPoint p2 = new SmellPoint(1,2);
     p1.equals(p2);
     // 처음에 ColorPoint의 equals로 비교 : 2번째 if문 때문에 SmellPoint의 equals로 비교
     // 이후 SmellPoint의 equals로 비교 : 2번째 if문 때문에 ColorPoint의 equals로 비교
     // 무한 재귀의 상태!
   }
   ```

   이를 해결하기 위해 instanceof가 아니라 getClass로 검사를 하면 된다.

   ```java
   @Override public boolean equals(Object o){
     if(o == null || o.getClass() != getClass())
       return false;
     Point p = (Point) o;
     return p.x == x && p.y == y;
   }
   ```

   하지만 이는 근본적인 해결책이 아니다.

   리스코프 치환 원칙을 위배한다.

   - Point의 하위클래스는 정의상 여전히 Point이기 때문에 어디서든 Point로 활용되어야 한다.

   > 리스코프 치환원칙 (Liskov substitution principle) : 어떤 타입에 있어 중요한 속성이라면 그 하위 타입에서도 마찬가지로 중요하다. 따라서 그 타입의 모든 메서드가 하위 타입에서도 똑같이 잘 작동해야한다.
   >
   > Point의 하위클래스는 정의상 여전히 Point이므로 어디서든 Point로 활용가능해야한다.

​          

진짜 사용할 수 있는 방법

- 상속대신 컴포지션을 사용하자.

```java
public class ColorPoint{
  private final Point point;
  private final Color color;
 
  public Point asPoint(){ //view 메서드 패턴
    return point
  }
  
  @Override public boolean equals(Object o){
    if(!(o instanceof ColorPoint)){
      return false;
    }
    ColorPoint cp = (ColorPoin) o;
    return cp.point.equals(point) && cp.color.equals(color);
  }
}
```

ColorPoint - ColorPoint : ColorPoint의 equals를 이용하여 color 값까지 모두 비교

ColorPoint - Point : ColorPoint를 asPoint() 메소드를 이용해 Point로 바꾸어서, Point의 equlas를 이용해 x,y만 비교

Point - Point : Point의 equals를 이용하여 x,y 값 모두 비교

​          

- 추상 클래스의 하위클래스 사용하기
  - 추상클래스의 하위클래스에서는 equals 규약을 지키면서도 값을 추가할 수 있다.
  - 상위 클래스를 직접 인스턴스로 만드는게 불가능하기 때문에 하위클래스끼리의 비교가 가능해진다.

​       

일관성

- null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.

- 두 객체가 같다면 (어느 하나 혹은 두 객체 모두가 수정되지 않는한) 앞으로도 영원히 같아야한다.
  가변객체 = 비교 시점에 따라 서로 다를 수 있다.불변객체 = 한번 다르면 끝까지 달라야한다.

- equals는 항시 메모리에 존재하는 객체만을 사용한 결정적(deterministic) 계산만 수행해야한다.
  클래스가 불변이든 가변이든 equals의 판단에 신뢰할 수 없는 자원이 끼어들면 안된다 : ex URL과 매핑된 호스트의 IP 주소

​       

null 아님

- null이 아닌 모든 참조값 x에 대해, x.equals(null)은 false이다.

- 모든 객체가 null 과 같지 않아야한다.

```java
@Override public boolean equals(Object o){
  if( o == null){
    return false;
  }
}
```

```java
@Override public boolean equals(Obejct o){
  if(!(o instanceof MyType)) 	// instanceof 자체가 타입과 무관하게 null이면 false 반환함.
    return false;
  MyType mt = (MyType) o;
}
```



양질의 equals 메서드를 구현하는 4단계

- == 연산자를 사용해 입력이 자기 자신의 참조인지 확인한다.
  - object identity를 검사한다.

- instanceof 연산자로 입력이 올바른 타입인지 확인한다.

- 올바른 타입의 경우 : equals가 정의된 클래스로 리턴이 되는가
- 올바른 타입이 아닌경우 ( == 구현한 특정 인터페이스) 
  - 구현한 (서로다른) 클래스간 비교가 가능하게 해야함
  - 이런 구현체들은 인터페이스의 equals를 이용하여 비교해야한다.

- 입력을 올바른 타입으로 형변환 한다.
  - 2번에서 instatnceof를 이용했기 때문에 100% 성공함

- 입력 객체와 자기 자신의 대응되는 '핵심' 필드들이 모두 일치하는지 하나씩 검사한다.
  - 2번에서 인터페이스를 사용했다면 입력의 필드값을 가져올 때도 인터페이스 메서드를 사용해야한다.

​            

기본타입과 참조타입

- 기본타입 : == 연산자 비교
  - float, double 필드 : Float.compare(float, float), Double.compare(double, double) 비교 (부동 소수 값으로 인해)
  - Float.equals(float)나 Double.equals(double) 은 오토 박싱을 수반할 수 있어 성능상 좋지 않다.
- 참조타입 : equals() 비교
- 배열 필드 : 원소 각각을 지침대로 비교한다. / 모두가 핵심 필드라면 Arrays.equals()를 사용한다.



 

null 정상값 취급 방지

- Object.equals(object, object) 로 비교하여 NullPointException 발생을 예방하자

 

필드의 표준형을 저장

- 비교하기 복잡한 필드는 필드의 표준형(canonical form)을 저장한후 비교 : 불변 클래스에 제격이다.

 

필드 비교 순서는 equals 성능을 좌우한다.

- 다를 가능성이 높은 필드 우선
- 비교 비용이 싼 필드 우선
- 핵심필드 / 파생필드 구분하자.

 

equals 재정의할 땐 hashCode도 반드시 재정의하자.

 

너무 복잡하게 해결하려 들지 말자.

 

Object 외의 타입을 매개변수로 받는 equals 메서드는 선언하지 말자.

```
public boolean equals(MyClass o) // @Override(재정의)가 아니라 다중정의 상태임!
```

---

### equals를 재정의하려거든 hashCode도 재정의하라

equals를 재정의한 클래스 모두에서 hashcode도 재정의해야 한다.

- 그렇지 않다면 hashCode 일반 규약을 어기게 되어 해당 클래스의 인스턴스를 hashMap이나 HashSet 같은 컬렉션의 원소로 사용할 때 문제를 일으킬 것이다.
- equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의 hashCode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다. (단, 애플리케이션을 다시 실행한다면 이 값이 달라져도 상관없다.)
- equals(Object)가 두 객체를 같다고 판단했다면, hashCode는 똑같은 값을 반환해야한다.
- equals(Objet)가 두 객체를 다르다고 판단했더라도, 두 객체의 hashCode가 서로 다른 값을 반환할 필요는 없다. 단, 다른 객체에 대해서는 다른 값을 반환해야 해시테이블의 성능이 좋아진다.



hashCode 재정의를 잘못했을 때 크게 문제가 되는 조항은 두 번째이다.

- 논리적으로 동치인 두 객체가 서로 다른 해시코드를 반환하여 두 번째 규약을 지키지 못하는 것이다.

​            

좋은 해시 함수라면 서로 다른 인스턴스에 다른 해시코드를 반환한다.
주어진 인스턴스들을 균일하게 분배한다.

만약 같은 값을 반환한다면, 객체가 해시테이블 버킷하나에 담기고, 그 객체들이 연결리스트처럼 동작한다.

```
@Override public int hashCode(){return 42;}
```

수행시간이 O(1)인 해시 테이블이 O(n)으로 느려진다.

> 해시 충돌이 발생한 경우이다.
>
> 모든 해시값이 동일하게 "42"로 나오기 때문에 Chaining에 연결된 리스트들까지 계속적으로 확인해야한다.
>
> 그에 따라, O(1) -> O(N)으로 늘어난다.



##### 좋은 해쉬 Code를 작성하기

1. int 변수 result를 선언한 후 값 c로 초기화한다. 
   - c는 핵심 필드를 2.a 방식으로 계산한 해쉬코드이다.
2. 해당 객체의 나머지 핵심 필드 f 각각에 대해 다음 작업을 수행한다.
   1. 해당 필드의 해시 코드 c를 계산한다.
      - 기본 타입 필드라면, Type.hashCode(f)를 수행한다. (여기서 Type은 해당 기본 타입의 박싱 클래스다.)
      - 참조 타입 필드 + equals가 재귀적으로 호출한다면 hascode도 재귀적 호출한다. (계산이 더 복잡해질 것 같다면, 이 필드의 표준형을 만들어 그 표준형의 hashCode를 호출한다. null이면 0을 사용)
      - 필드가 배열이라면, 핵심 원소 각각을 별도 필드처럼 다룬다. 
        - 모든 원소가 핵심 원소라면 Arrays.hashCode, 하나도 없다면 단순 상수 (0)
   2. 단계 2.A에서 계산한 해시코드 C로 result를 갱신한다.
3. result를 반환

​            

```java
@Override public int hashCode(){
	int result = Short.hashCode(areaCode);
	result = 31 * result + Short.hashCode(prefix);
	result = 31 * result + Short.hashCode(lineNum);
	return result;
}
```



##### hashCode가 구현된 뒤

1. 이 메서드가 동치인 인스턴스에 대해 똑같은 해시코드를 반환할지 자문해보자.
   1. 단위 테스트를 작성하자.

2. 파생 필드는 해시코드 계산에서 제외해도 된다. (다른 필드로부터 계산해낼 수 있는 필드는 모두 무시)  + equals 비교에 사용되지 않은 필드는 반드시 제외해야한다.

3. 단계 2.B의 곱셈 31 * result는 필드를 곱하는 순서에 따라 result 값이 달라지게 한다.
   - 곱셈 없이 구현한다면 아나그램에 대해 해시코드가 같아진다.
   - 31은 홀수이면서 소수이기에 선정했다.

4. Objects 클래스는 임의의 개수만큼 객체를 받아 해시코드를 계산해주는 정적 메소드인 hash를 제공하나 속도가 느리다. 그러니 성능이 민감하지 않은 상황에서 사용하자.

```java
@Override public int hashCode(){
	return Objects.hash(lineNum, prefix, areaCode);
}
```

4. 클래스가 불변이고 해시코드를 계산하는 비용이 크다면, 캐싱하는 방식을 고려하자.

```java
private int hashCode;

@Override public int hashCode(){
  int result = hashCode;
  if(result == 0){
    int result = Short.hashCode(areaCode);
    result = 31 * result + Short.hashCode(prefix);
    result = 31 * result + Short.hashCode(lineNum);
    hashCode = result;
  }
  return result;
}
```

4. 성능을 높인답시고 해시코드를 계산할 때 핵심 필드를 생략해서는 안 된다.
   - 성능을 심각하게 떨어뜨린다.
   - 수많은 인스턴스가 단 몇 개의 해시코드로 집중되어 속도가 선형으로 느려질 수 있다.
5. hashCode가 반환하는 값의 생성 규칙을 API 사용자에게 자세히 공표하지 말자.
   - 클라이언트가 이 값에 의지하지 않고 추후에 계산 방식을 바꿀 수도 있기 때문이다.

---

### toString을 항상 재정의하라

Object의 기본 String 메서드가 우리가 작성한 클래스에 적합한 문자열을 반환하는 경우는 거의 없다.

PhoneNumber@adbbd - 클래스_이름@16진수로_표시한_해쉬코드

​        

toString 일반 규약

1. 간결하면서 사람이 읽기 쉬운 형태의 유익한 정보를 반환해야한다.
2. 모든 하위 클래스에서 이 메서드를 재정의해야한다.

​        

equals와 hashCode 규약만큼 대단히 중요하진 않지만, toString을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고, 그 클래스를 사용한 시스템은 디버깅하기 쉽다.

toString 메서드는 println, printf, assert 구문에 넘길 때, 혹은 디버거가 객체를 출력할 때 자동으로 불린다.

실전에서 toString은 그 객체가 가진 주요 정보 모두를 반환하는 게 좋다.

- 객체가 거대하거나 객체의 상태가 문자열로 표현하기에 적합하지 않다면 요약 정보를 넘기자.

​          

toString을 구현할 때 반환값의 포맷을 문서화할지 정하자.

- 전화번호나 행렬 같은 값 클래스라면 문서화하면 좋다.
- 명시한 포맷에 맞는 문자열과 객체를 상호 전환할 수 있는 정적 팩터리나 생성자를 함께 제공하기
  - Integer.toString(); / Integer.parseInt(string);
- 장점
  - 표준적이고, 명확하고, 사람이 읽을 수 있다.
  - 값 입출력 사용
  - CSV 같이 데이터 객체 저장도 가능
- 단점
  - 포맷을 한번 명시하면 평생 그 포맷에 얽매이게 된다.





포맷을 명시하든 아니든 우리의 의도는 명확히 밝혀야 한다.

포맷 명시 여부와 상관없이 toString이 반환한 값에 포함된 정보를 얻어올 수 있는 API를 제공하자.

- 각각의 정보에 대해 접근할 수 있는 getter 같은 것을 제공하자.



정적 유틸리티 클래스 / 부분 열거 타입은 toString을 재정의하지 않아도 된다.

하위 클래스들이 공유해야할 문자열 표현이 있다면 toString을 재정의한다.ex ) 컬렉션 구현체 : 추상 컬렉션 클래스의 toString() 메서드를 상속해서 사용한다.

---

### clone 재정의는 주의해서 진행하라

Cloneable은 복제해도 되는 클래스임을 명시하는 용도의 믹스인 인터페이스지만 의도한 목적을 제대로 이루지 못했다.

- 믹스인 - 클래스가 자신의 "본래 타입"에 추가하여 구현할 수 있는 타입. 선택 가능한 기능을 제공하며, 그 기능을 제공받고자 하는 클래스에서 선언한다 
  - ex) comparable

clone 메서드가 선언된 곳은 object이며 그마저도 protected이다.

그래서 Cloneable을 구현하는 것만으로는 외부 객체에서 clone 메서드를 호출할 수 없다.

Cloneable은 Object의 protected 메서드인 clone의 동작방식을 결정한다.

- Cloneable을 구현한 예는 상당히 이례적이니 따라하지 말자.

​                 

clone 호출 + Cloneable 구현 O : 객체의 필드들을 하나하나 복사한 객체 반환

clone 호출 + Cloneable 구현 X CloneNotSupportedException   

​           

clone 메서드의 일반 규약

클론객체와 원본객체는 물리적 동등성을 보장한다.

- x.clone() != x

- x.clone().getClass() == x.getClass()

 

클론객체와 원본객체는 논리적 동등성을 보장한다. (일반적으로 참이지만 필수는 아니다.)

- x.clone().equals(x)

- x.clone().getClass() == x.getClass()



상속에서의 주의점

생성자 연쇄(constructor chaining)과 비슷하다

clone 메서드가 super.clone이 아닌 생성자를 호출해 얻은 인스턴스를 반환해도 컴파일러는 불평하지 않을 것이다.

하지만, 이렇게 될 경우 하위 타입의 클래스의 반환하는 것이 아니라 상위 타입의 클래스를 반환하기에 제대로 동작하지 않는다.

clone을 재정의한 클래스가 final이면 하위 클래스가 없으니 관례를 무시해도 안전하다.

​                

상위 클래스를 제대로 상속했을 때 Cloneable 구현

super.clone을 호출한다. (클래스에 정의한 모든 필드가 원본과 같다.)

불변 클래스에서는 굳이 clone 메서드를 제공하지 않는게 좋다 (기존의 super.clone으로 해결)

```
@Override public PhoneNumber clone(){
  try{
    return (PhoneNumber) super.clone();
  }catch(CloneNotSupportedException e){
    throw new AssertionError();	// 막기위해선 implements Cloneable
  }
}
```

Object의 clone은 Object를 반환하지만 PhoneNumber에서는 PhoneNumber를 반환하게 하였다.

재정의한 메서드의 반환타입은 상위클래스 메서드가 반환하는 타입(Object)의 하위 타입(PhoneNumber)일 수 있다.

자바의 공변 반환 타이핑 (convariant return typing) 지원 덕분이다.

- 공변 반환 타이핑 : T'가 T의 subType이면, C<T'>는 C<T>의 SubType이다.

​                     

하지만 다음과 같은 경우에 위와 같은 방식을 적용하면 제대로 동작하지 않는다.

```java
public class Stack{
  private Object[] elements;
	private int size;
}

@Override public Stack clone(){
  try{
  	Stack result = (Stack)super.clone();
    result.elements = elements.clone();
    return result
  }catch (CloneNotSupportedException e){
    throw new AssertionError():
  }
}
이렇게 복사를 하지 않는다면 복사한 객체는 elements의 참조값을 갖고있어, 원본객체를 수정하면 복사객체도 수정되는 현상이 일어날 수 있다.

clone 메서드는 사실상 생성자와 같은 효과를 낸다.
clone은 원본 객체에 아무런 해를 끼치지 않는 동시에 복제된 객체의 불변식을 보장해야한다.
```

elements가 가변 객체이기 때문이다.

그래서 참조 값을 들고 있기에 원본 Stack에서의 elements 변환이 clone Stack에 영향을 미치게 된다.

그에 따라 elements 또한 복사해줘야한다.

이 때 배열의 clone 메서드를 사용하면 된다.

​         

HashTable에서의 복제 (복잡한 가변 객체의 복제)

해시테이블 내부 : 버킷들의 배열 + 각 버킷을 키-값 쌍을 담는 연결리스트의 첫 번째 엔트리 참조

1) 버킷 복제 -> 버킷 배열을 복제하나, 버킷 배열안에잇는 연결리스트들은 모두 원본과 같은 것들이다.

2) 각 버킷을 구성하는 연결 리스트를 복사해야한다.

3. 연결 리스트를 복제할 때 재귀적으로 호출하는 방식을 사용한다.
   1. 스택프레임을 소비하므로 스택 오버플로를 낼 가능성이 있다.
   2. 재귀 호출대신 반복자를 써서 순회한다.
   3. 원본 객체의 상태를 다시 생성하는 고수준 메서드를 호출한다. put(key,value)

  저수준 API 보다는 속도가 느리다. + Cloneable 아키텍처의 기초인 필드 단위 객체 복사를 우회한다.

​          

상속에서의 clone

Cloneable 구현 여부를 하위 클래스에서 선택하도록 해준다.

clone을 동작하지 않게 구현해놓고 하위클래스에서 재정의 못하게 한다.

```java
@Override
protected final Object clone() throws CloneNotSupportedException{
  throw new CloneNotSupportedException();
}
```

​          

clone() 재정의 방법

- Cloneable을 구현하는 모든 클래스는 clone을 재정의해야 한다.
- 접근 제한자는 public으로 설정한다.
- 반환타입은 클래스 자신으로 설정한다.
- 가장 먼저 super.clone을 호출 한 후 필요한 필드를 적절히 수정한다
- 이후 깊은 구조까지 클론한다. (보통 재귀이지만, 항상 정답은 아니다.)
- 기본 타입 필드, 불변 객체 참조만 갖는 클래스면 아무 필드도 수정할 필요가 없다.
- 고유 ID는 비록 기본타입, 불변이어도 수정해야한다.

​         

웬만하면 clone 대신 복사 생성자 혹은 복사 팩터리를 사용하자.



복사 생성자 : 단수히 자신과 같은 클래스의 인스턴스를 인수로 받는 생성자

```
public Yum(Yum yum){...};
```



복사 팩터리 생성

```
public static Yum newInstance(Yum yum){...};
```

​           

복사 생성자, 팩터리의 장점

- 위험한 객체 생성 매커니즘을 사용하지 않는다. (생성자 없이 객체 생성)

- 문서화된 규약에 기대지 않는다

- final 필드 용법과 충돌하지 않음

- 불필요한 검사 예외를 던지지 않음

- 형변환 필요가 없다.

- 해당 클래스가 구현한 '인터페이스' 타입의 인스턴스를 인수로 받을 수 있다.

  인터페이스 기반 복사 생성자 = 변환 생성자 (conversion constructor)
  인터페이스 기반 복사 팩터리 = 변환 팩터리 (conversion factory)

---

### Comparable을 구현할지 고려하라

compareTo는 Object의 메서드가 아니다.

성격은 두가지만 빼면 Object의 equals와 같다.

- compareTo는 단순 동치성 비교에 더해 순서까지 비교 가능하다.
- 그 클래스의 인스턴스들에 자연적인 순서가 있음을 뜻할 수 있다.

그래서 Comparable을 구현한 객체들의 배열은 손쉬운 정렬이 가능하다.

알파벳, 숫자, 연대 등 순서가 명확한 값 클래스 작성할땐 구현하자.

​         

compareTo 메서드의 일반 규약은 equals의 규약과 비슷하다.

> 객체의 순서를 비교한다.
>
> 객체보다 작은면 음의 정수, 같으면 0, 크면 양의 정수를 반환한다. 
>
> 객체와 비교할 수 없는 타입의 객체가 주어지면 ClassCastException을 던진다.
>
> ​           
>
> 반사성, 추이성, 대칭성
>
> sgn(x.compareTo(y)) == -sgn(y.compareTo(x))
>
> - 두 객체 참조의 순서를 바꾸어 비교해도 예상된 결과가 나와야 한다.
> - 좌변이 예외를 던진다면 우변도 예외를 던져야한다.
>
> x.compareTo(y) == 0이면 sgn(x.compareTo(z)) == sgn(y) == sgn(y.compareTo(z))이다.
>
> - Compareable을 구현한 클래스 모든 z에 대해 성립해야 한다.
> - 첫번째 < 두번째, 두번째 < 세번째 => 첫번째 < 세번째
>
> (x.compareTo(y) == 0) == (x.equals(y))여야 한다.
>
> - 권고가 필수는 아니지만 꼭 지키는 게 좋다.
> - 이 클래스의 순서는 equals 메서드와 일관되지 않는다.
> - 크기가 같은 객체들끼리는 어떤 객체와 비교하더라도 항상 같아야 한다.



컬렉션 구현 인터페이스(Collection, Set, Map) - 구현에 따른 주의가 필요하기 때문이다.
: equals 메서드 규약을 따른다 되어있다.
: 정렬된 컬렉션들은 동치성 비교시 equals대신 compareTo 사용

 

equals와 마찬가지로 기존 클래스를 확장한 구체클래스에서 새로운 값 컴포넌트를 추가하면 compareTo 지킬 방법이 없다.

우회법 : 컴포지션을 사용하고 + '뷰' 메서드를 제공하자

​             

compareTo 메서드 작성요령

equals와의 차이점만 주의하면 된다.

- Comparable은 타입을 인수로 받는 제네릭 인터페이스이다 
  - 메서드의 인수타입은 컴파일타임에 정해진다.
  - 따로 형 비교를 진행하지 않아도 된다.
- compareTo 메서드는 필드의 동치가 아니라 순서를 비교한다.Comparable을 구현하지 않았다면, Comparator를 사용할 수 있다.
- compareTo 메서드 구현시 관계연산자 <, > 사용하는 방식은 거추장 스럽고 오류를 유발한다.

```
// 아래 방법을 사용하자.
Integer.compare(a,b);
Float.compare(a,b);
Double.compare(a,b);
```

  클래스의 핵심필드 여러개중 어떤것을 먼저 비교할 지에 대해 집중하라

​                         

비교자 생성 메서드(comparator construction method)와 팀을 꾸려 메서드 연쇄로 비교자를 생성

```
private static final Comparator<PhoneNumber> COMPARATOR =
  comparingInt((PhoneNumber pn)->pn.areaCode)	// Comparator의 인스턴스 메서드
  	.thenComparingInt(pn -> pn.prefix)			// 원하는 만큼 연달아 호출 가능
		.thenComparingInt(pn -> pn.lineNumber);

public int compareTo(PhoneNumber pn){
  return COMPARATOR.compare(this, pn);
}
```

  람다에서 입력 인수의 타입을 명시 (처음에만 명시 후 뒤에는 자바가 알아서 타입 추론을 진행한다.)

Comparator의 보조 생성 메서드

- comparingLong, thenComparingLong
-  comparingDouble, thenComparingDouble

값의 차를 이용한 compareTo, compare 메서드를 사용하지 말자.

- 정수 오버플로 / 부동 소수점 계산 방식 오류 

이렇게 사용하자. => Integer.compare(a,b); || Comparator.comparingInt(x -> x.hashCode())

---

### 클래스와 멤버의 접근 권한을 최소화하라

어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는 바로 클래스 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐다.

잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨 구현과 API를 깔끔히 분리한다.

정보 은닉의 장점

- 시스템 개발 속도를 높인다 
  - 여러 컴포넌트를 병렬로 개발할 수 있기 때문이다.
- 시스템 관리 비용을 낮춘다.
  - 각 컴포넌트를 더 빨리 파악하여 디버깅할 수 있고, 다른 컴포넌트로 교체하는 부담도 적기 때문이다.
- 정보 은닉 자체가 성능을 높여주지는 않지만, 성능 최적화에 도움을 준다.
  - 완성된 시스템을 프로파일링해 최적화할 컴포넌트를 정한 다음 다른 컴포넌트에 영향을 주지 않고 해당 컴포넌트만 최적화할 수 있기 때문이다.
- 소프트웨어 재사용성을 높인다.
  - 외부에 거의 의존하지 않고 독자적으로 동작할 수 있는 컴포넌트라면 그 컴포넌트와 함께 개발되지 않은 낯선 환경에서도 유용하게 쓰일 가능성이 크기 때이다.
- 큰 시스템을 제작하는 난이도를 낮춰준다.
  - 시스템 전체가 아직 완성되지 않은 상태에서도 개별 컴포넌트의 동작을 검증할 수 있기 때문이다.

​             

각 요소의 접근성은 그 요소가 선언된 위치와 접근 제한자(private, protected, public)로 정해진다.

이 접근 제한자를 제대로 활용하는 것이 정보 은닉의 핵심이다.

모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다.



톱레벨 클래스(가장 바깥)와 인터페이스에 부여할 수 있는 접근 수준은 package-private과 public 두 가지이다.

- public : 공개 API
- package-private : 해당 패키지 안에서만 사용 가능 (패키지 외부에서 쓸 이유가 없을 때 사용하자)
  - 클라이언트에 아무런 피해 없이 다음 릴리스에서 수정, 교체, 제거할 수 있다.

​       

한 클래스에서만 사용하는 package-private 클래스의 경우에는 private static으로 중첩시키자.

접근 범위가 좁은 순서

- private : 멤버를 선언한 톱레벨 클래스에서만 접근할 수 있다.
- package-private : 멤버가 소속된 패키지 안의 모든 클래스에서 접근할 수 있다. 접근 제한자를 명시하지 않았을 때 적용되는 패키지 접근 수준이다.
- protected : package-private의 접근 범위를 포함하며, 이 멤버를 선언한 클래스의 하위 클래스에서도 접근할 수 있다.
- public : 모든 곳에서 접근할 수 있다.

​      

클래스의 공개 API를 세심히 설계한 후, 그 외의 모든 멤버는 private으로 만들자.

오직 같은 패키지의 다른 클래스가 접근해야 하는 멤버에 한하여 pakcage-private으로 풀어준다.

- 권한이 풀어주는 일이 생긴다면 컴포넌트를 더 분해해야 하는 것은 아닌지 고민해보자.

​          

public 클래스에서는 멤버의 접근 수준을 package-private에서 protected로 바꾸는 순간 공개 API로 사용되어진다.

또한, 상위클래스의 메서드를 재정의할 때는 상위보다 좁게 설정할 수 없다.

- 리스코프 치환을 지키기 위함이다.

​        

테스트를 위해 private을 package-private로 풀어줄 수는 있으나 그 이상은 삼가하자.

public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.



public 가변 필드를 갖는 클래스는 일반적으로 스레드 안전하지 않다.

- 필드의 불변성을 잃게 된다.(final이나 불변 객체를 참조하더라도..)

정적필드도 마찬가지이지만 public static final의 경우 공개해도 된다.

- 대문자 알파벳으로 쓰며, 각 단어 사이에 밑줄을 넣는다.
- 반드시 기본 타입 값이나 불변 객체를 참조해야한다.



클래스에서 public static final 배열 필드를 두거나 이 필드를 반환하는 접근자 메서드를 제공해서는 안 된다.

- 배열의 내용을 수정할 수 있기 때문이다.

그러면 어떻게 사용해야할까?

1. private 전환 후 불변리스트를 public으로 제공한다.

```java
private static final Thing[] PRIVATE_VALUES = {...};
public static final List<Thing> VALUES = Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));
```

2. 복사본을 반환하는 public 메서드를 추가한다. (방어적 복사)

```java
private static final Thing[] PRIVATE_VALUES = {...};
public static final Thing[] values(){
  return PRIVATE_VALUES.clone();
}
```



모듈 시스템 개념의 도입

패키지 : 클래스의 묶음 // 모듈 : 패키지의 묶음

모듈 : 자신에 속하는 패키지 중 공개 (export) 할 것들을 선언한다. [module-info.java 파일에]

클래스를 외부에 공개하지 않으면서도 같은 모듈을 이루는 패키지 사이에서 자유롭게 공유할 수 있다.

암묵적 접근 수준 : public, protected 수준의 효과가 모듈 내부로 한정된다.

 

모듈에 적용되는 새로운 두 접근 수준은 주의해야한다.

모듈의 jar파일을 모듈 경로가 아니라 애플리케이션 클래스 패스에 두면, 모듈안 패키지가 모듈이 없는 것 처럼 행동한다.

*일반 클래스 파일이 있는 것처럼 행동한다 : 모듈 시스템 암묵적 접근 수준이 해제된다*

JDK : 자바라이브러리에서 공개하지 않은 패키지는 모듈 밖에서 접근 할 수 없다.

 

ㄴ모듈의 장점을 누리기 위한 조치

- 패키지를 모듈 단위로 묶는다.
- 모듈 선언에 패키지들의 의존성을 명시한다.
- 소스트리 재배치
- 모듈 안으로 부터 (모듈 시스템을 적용하지 않는) 일반 패키지로의 모든 접근에 특별한 조치를 취해야한다.

그러나 모듈의 개념은 아직은 사용하지 않는게 좋은 것 같다.

---

### public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라

public 클래스의 가변 필드

- 절대 가변 필드를 public으로 노출하면 안된다.
  - 캡슐화의 이점을 제공하지 못한다.
  - API를 수정하지 않고는 내부 표현을 바꿀 수 없다.
  - 불변식을 보장할 수 없다.
  - 외부에서 필드에 접근할 때 부수 작업을 수행할 수도 없다.



패키지 바깥에서 접근할 수 있는 public 클래스라면 멤버를 private으로 하고 접근자를 사용하자.

package-private 클래스 혹은 private 중첩 클래스라면 데이터 필드를 노출한다 해도 하등의 문제가 없다.

- package-private : 패키지 바깥 코드를 손대지 않고 데이터 표현 방식을 바꿀 수 있다.
- private 중첩 : 이 클래스를 포함하는 외부 클래스까지로 제한한다.

​                  

public 클래스의 불변 필드

가변필드를 직접 노출할 때보다는 단점이 조금 줄어들지만 여전히 좋은 생각은 아니다.

불변식을 보장할 수 있지만 다음과 같은 단점이 존재한다.

- 단점
  - API를 변경하지 않고는 표현방식을 바꿀 수 없다.
  - 필드를 읽을 때 부수적인 작업을 수행할 수 없다.

---

### 변경 가능성을 최소화하라

불변 클래스란 인스턴스의 내부 값을 수정할 수 없는 클래스이다.

- String, BigInteger, BigDecimal

불변 클래스는 가변 클래스보다 설계하고 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 훨씬 안전하다.

​          

불변 클래스 만드는 5가지 규칙

- 객체의 상태를 변경하는 메서드를 제공하지 않는다.
- 클래스를 확장할 수 없도록 한다.
- 모든 필드를 final로 선언한다.
- 모든 필드를 private으로 선언한다.

- 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
  - 클래스에 가변 객체를 참조하는 필드가 하나라도 있다면 클라이언트에서 그 객체의 참조를 얻을 수 없도록 해야 한다.
  - 접근자가 객체 참조를 반환해서는 안된다.
  - 생성자, 접근자, readObject 메서드 모두에서 방어적 복사를 수행해라.

​           

불변 객체의 장점

1. 근본적으로 스레드 안전하다.
   - 동기화 할 필요가 없다.

2. 불변객체는 안심하고 공유 가능하다.
   - 스레드 간 영향을 주고받을 수 없다.
   - 방어적 복사도 필요없다 > clone 메서드 복사 생성자 필요 없다
     - String 클래스의 복사생성자는 되도록 사용하지 말자

3. 한번 만든 인스턴스 최대한 재활용 가능하다.
   - 자주 사용되는 인스턴스를 생성하여, 정적팩터리를 제공할 수 있다.
   - 메모리 사용량 감소 / 가비지 컬렉션 비용 감소
     - BigInteger, Wrapper Class
4. 불변객체는 자유롭게 공유할 수 있음은 물론, 불변 객체끼리는 내부 데이터를 공유할 수 있다.
   - BigInteger에서 negate 함수에서 mag는 재사용하는 것을 확인할 수 있다.

5. 불변객체는 그 자체로 실패 원자성을 제공한다.
   - 메서드에서 예외가 발생한 후에도 그 객체는 메서드 호출전 상태와 같은 유효한 상태를 가진다.

​            

불변 객체의 단점

값이 다르면 반드시 독립된 객체로 만들어야 한다.값의 가짓수가 많으면 이를 모두 만드는데 큰 비용이 필요하다.

흔히 쓰일 다단계 연산들을 예측이 될 때. 다단계 연산 속도를 높여주는 가변 동반클래스를 package-privated으로 둔다.

흔히 쓰일 다단계 연산들이 예측이 안될 때. 다단계 연산 속도를 높여주는 가변 동반클래스를 public 으로 둔다.

​                 

불변클래스를 만드는 설계 방법

final 클래스

- final을 클래스 레벨에 붙여 상속을 막는다.

정적 팩터리를 제공하는 방법

- 모든 생성자를 private 혹은 package-private으로 만들고 public 정적 팩터리를 제공한다. 
- 캐싱 기능 추가도 가능하다.
- public이나 protected 생성자가 없으니 다른 패키지에서는 이 클래스를 확장하는게 불가능하기 때문이다.

​       

BigInteger, BigDecimal 설계시 주의점

이 두 클래스의 메서드가 모두 재정의할 수 있게 설계되어있다.
인수로 받은 객체가 '진짜'인지 확인하고, 이 인수들은 가변으로 가정하고 방어적으로 복사해서 사용해야한다.

​               

불변 객체 기준 완화

"어떤 메서드도 객체의 상태 중 외부에 비치는 값을 변경할 수 없다."
계산 비용이 큰 값을 나중에 계산하여 final 이 아닌 필드에 캐싱해둔다.

실제로 String 클래스는 불변객체이지만, final이 아닌 필드 hash를 이용해 캐시하여 hashcode 재 연산 비용을 줄인다.
            

클래스가 꼭 가변이어야 하지 않을 경우에는 불변이어야 한다. 

Getter가 있다고 해서 Setter를 무조건 만들지 말자

무거운 값 객체의 경우 성능때문에 어쩔수 없다면, 불변 클래스와 쌍을 이루는 가변 동반 클래스를 public 클래스로 제공하자.

불변으로 만들 수 없는 클래스라도 변경할 수 있는 부분을 최소한으로 줄이자

다른 합당한 이유가 없다면 모든 필드는 private final이어야 한다.

생성자는 불변식 설정이 모두 완료된, 초기화가 완벽히 끝난 상태의 객체를 생성해야한다.

