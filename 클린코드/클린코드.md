## 2. 의미있는 이름

- 의도가 분명한 이름을 지어라.
  - 개념에 명확한 이름을 부여하자.
- 그릇된 정보를 피하라.
  - 보편적인 의미를 다른 의미로서 사용하지말자.
  - 다른 모듈과 흡사한 이름을 사용하지말자.
  - 유사한 개념은 유사한 표기법을 사용하자.
- 의미있게 구분하라.
  - 읽는 사람이 차이를 알도록 네이밍하자.
- 발음하기 쉬운 이름을 사용하라.
- 검색하기 쉬운 이름을 사용하라.

- 인코딩을 피하라.
  - 헝가리식 표기 , 멤버 변수 접두어 -> 구닥다리---
- 클래스 이름, 객체 이름
  - 명사 or 명사구 + 동사 피하자.
  - ex) Customer ... 
- 메서드 이름
  - 동사 or 동사구
  - 정적 팩토리 메서드를 적극 활용하자.

- 한 개념에 한 단어를 사용하라.
  - 일관성 있는 어휘를 사용하자.
- 한 단어를 두 가지 목적으로 사용하지 마라.
- 해법 영역에서 가져온 이름을 사용하라.
- 문제 영역에서 가져온 이름을 사용하라.

- 의미 있는 맥락을 추가하라.



## 3. 함수

- 작게 만들어라.
  - 들여쓰기 수준은 1단이나 2단을 넘어서지 말자.
- 한 가지만 해라.
  - 한 가지라는 것은 추상화의 기준을 말한다.
- 함수 당 추상화 수준은 하나로!
  - 추상화 수준이 섞지 말자.
  - 추상화 수준은 단계별로 내려가도록 구성하자.
- Switch문의 사용은 자제하자.
  - 사용한다면 객체를 생성하는 팩토리로 사용하자.
- 서술적인 이름을 사용하자.
- 함수 인수는 최대한 적게 하자.
  - 플래그를 자제하자.
- 부수 효과를 일으키지 마라.
- 명령과 조회를 분리하라.
- 오류 코드보다 예외를 사용하라.
- 반복하지 마라.



## 4. 주석

- 주석은 실패를 도와주는 보조제일뿐이다.
  - 주석은 최대한 줄이되 코드를 정확하게 짜자.
- 주석은 나쁜 코드를 보완하지 못한다.
  - 오히려 주석없고 깔끔한 코드가 더 낫다.

- 코드로 의도를 표현하라.
- 좋은 주석
  - 법적인 주석 - 회사가 정립한 구현 표준에 맞춰 법적인 이유로 주석을 넣는 것
  - 정보를 제공하는 주석 - 주석이 필요없는 코드를 만든다면 더 좋지 않겠는가?
  - 의도를 설명하는 주석
  - 의미를 명료하게 밝히는 주석
  - 결과를 경고하는 주석
  - TODO 주석 - 떡칠한다면 좋은 코드가 되지 못한다.
  - 중요성을 강조하는 주석
  - 공개 API에서 JavaDocs

- 나쁜 주석

  - 주절거리는 주석
    - 주석을 달기로 다짐했다면 최선을 다해서 달자. 단순 과정이라 생각해서 대충할 생각은 버리자.
  - 같은 이야기를 중복하는 주석
  - 오해할 여지가 있는 주석
  - 의무적으로 다는 주석
  - 있으나 마나 한 주석

  - 무서운 잡음
  - 위치를 표시하는 주석
    - 가끔 다는 배너는 나쁘지 않다.
  - 닫는 괄호에 다는주석
    - 작고 캡슐화된 함수에는 잡음일 뿐이기에, 차라리 함수를 줄이자.
  - 공로를 돌리거나 저자를 표시하는 주석
  - 주석으로 처리한 코드
  - HTML 주석
  - 전역정보
    - 근처에 있는 코드만 기술하고 시스템의 전반적인 정보를 기술하지 마라.
  - 너무 많은 정보
  - 모호한 관계
  - 함수 헤더
  - 비공개 코드에서 Javadocs



## 5. 형식 맞추기

- 코드 형식은 의사소통의 일환이다. 

- 코드는 유지보수와 확장에 지대한 영향을 끼치기에 중요하다.

- 적절한 행 길이를 유지하라.
- 신문 기사처럼 작성하라.
  - 이름은 간단하면서도 설명이 가능하게
  - 고차원 개념 -> 저차원 개념
  - 일정한 형식으로
- 개념은 빈 행으로 분리하라.
  - 빈 행은 새로운 개념을 시작한다는 시각적 단서
- 세로 밀집도
  - 세로 밀집도는 연관성을 의미
- 수직 거리
  - 서로 밀접한 개념은 세로로 가까이 둬야 한다.
  - 서로 밀접한 개념은 한 파일에 속해야 한다. (protected 변수를 피해야 하는 이유)
  - 변수는 사용하는 곳에 최대한 가까이 선언한다.
  - 인스턴스 변수는 클래스 맨 처음에 선언한다.
  - 종속 함수 -> 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다.
  - 개념적 유사성 -> 개념적 친화도가 높을수록 가까이 배치한다.
    - 종속 함수와 같은 직접적인 종속성
    - 비슷한 동작
- 세로 순서
  - 호출되는 함수를 호출하는 함수보다 나중에 배치한다.
    - 고차원 -> 저차원 (자연스럽게)
- 가로 형식 맞추기
- 가로 공백과 밀집도
  - 할당문 "=" 좌우에는 공백 -> 나뉜다는 명백한 사실
  - 함수 인자가 하나일시 공백 X -> 상당히 밀접한다는 사실
  - 인자가 여러개일시 공백으로 구분

- 가로 정렬
  - 정렬은 오히려 읽는데 방해를 준다.

- 들여쓰기
  - 범위를 표현하기 위함이다.
  - 가독성에 큰 영향을 준다.
- 가짜 범위
  - 세미콜론을 제대로 사용하자.

## 6. 객체와 자료구조

- 자료 추상화
  - 자료를 세세하게 공개하기보다는 추상적인 개념으로 표현하는 편이 좋다.
  - 아무 생각 없는 Getter/Setter는 독이다.
- 자료/객체 비대칭
  - 객체 -> 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개
  - 자료 구조 -> 자료를 그대로 공개하며 별다른 함수 제공 X
  - 절차지향과 객체지향 사이의 딜레마
    - 절차지향
      - 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다.
      - 새로운 자료 구조를 추가하기 어렵다.
    - 객체지향
      - 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.
      - 새로운 함수를 추가하기 위해 모든 클래스를 수정해야한다.

- 디미터 법칙
  - 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다. (여러 개의 도트를 사용하지 말자.)
  - User(Class) -> Address(class) -> region(instance variable)
    - user.getAddress().getRegion() => 디미터의 법칙 어김
    - User 내부에 Address를 확인하는 isXXXXX()를 만들어 이를 활용 (불필요한 Getter/Setter 제거)
- 잡종 구조
  - 절반은 객체, 절반은 자료 구조
    - 비공개 변수를 그대로 노출하는 위험
    - 양쪽에서의 단점만 모아놓는 셈
- 구조체 감추기
  - 객체라면 내부 구조를 감춰야한다.

- 자료 전달 객체(DTO)



##### 어떤 시스템을 구현하는데 있어 새로운 자료 타입을 추가하는 유연성이 필요하면 객체

##### 새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합



## 7. 오류 처리

- 오류 코드보다 예외를 사용하라.
  - 오류 코드는 호출자 코드를 복잡하게 만든다.
  - 차라리 예외를 던지자.

- Try-Catch-Finally 문부터 작성하라.
  - 강제로 예외를 일으키는 Test Case를 작성 후 테스트를 통과하게 코드를 작성하는 방법이 좋다.
- 미확인 예외를 사용하라.
  - 확인 예외 -> IOException, ClassNotFound ...
  - 미확인 예외 -> RuntimeException..
  - 확인 예외는 OCP를 위반한다. 
    - 하위에 확인 예외가 존재한다면 상위에서 전부 해당 예외를 선언해야한다.
    - A -> B -> C (IOException !) -> A throws IOException -> B throws IOException -> C Throws IOException
  - 확인 예외는 상위에서 하위의 예외를 "인지"하고 있으므로 "캡슐화"가 깨진다.
- 예외에 의미를 제공하라.
  - 전후 상황을 충분히 붙인다.
  - 로깅 기능을 사용해 catch 블록에 대한 충분한 단서를 남기자.
- 호출자를 고려해 예외 클래스를 정의하라.
  - 외부 API를 사용할 때 감싸기 기법을 사용하라.
    - 외부 API를 감싸면 외부 라이브러리와 프로그램 사이에서의 의존성이 크게 줄어든다.
      - 다른 라이브러리로 바꾸더라도 비용이 적다.

- 정상 흐름을 정의하라.
  - 특수 사례 패턴 -> 클래스를 만들거나 객체를 조작해 특수 사례를 처리

- null을 반환하지 마라.
  - 단순 null 확인이 누락된 부분도 문제가 되지만 null 확인 처리가 "많을 경우"도 문제가 크다.
    - ex) list의 경우 null 대신 빈 리스트를 반환
- null을 전달하지 마라.
  - 애초에 null을 넘기지 않으면 null 처리에 대한 고민의 여지가 줄어든다.



##### 깨끗한 코드란 읽기도 좋아야 하지만 안정성도 높아야 한다.

##### 오류 처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하자.



## 8. 경계

- 외부 코드 사용하기

  - 외부 코드 제공자 -> 범용성 넓게  

  - 외부 코드 사용자 -> 자신에게 맞게 (객체 유형, 필요한 기능)

  - 어떻게 간극을 좁힐까?

    - 객체 유형을 제한하자.

      - 단순 Casting을 하기보다 제네릭스를 사용하면 코드의 가독성이 증가한다.

      - 필요한 기능을 제한해야하는데...?

      - 인터페이스가 변하면 수정할 코드가 상당히 많아질텐데...?

        - 사용자에 맞는 클래스 하나를 정의해 경계 인터페이스를 감싸 숨기자.
          - 필요한 객체유형만 제한
          - 필요한 인터페이스만 제공

        - Map 클래스와 같은 경계 인터페이스들은 생각없이 아무데나 넘기지 말자.

- 경계 살피고 익히기
  - 학습 테스트를 통해 외부 라이브러리를 제대로 학습한 후 적용해보자.
    - 곧바로 우리 코드에 외부 라이브러리를 적용해보는 것이 아니라 간단한 테스트 케이스를 작성하면서 외부 라이브러리를 익히는 것이 학습 테스트이다.
- 학습 테스트는 공짜 이상이다.
  - 패키지 새 버전이 나온다면 학습 테스트를 통해 차이가 있는지 검증 가능하다.

- 아직 존재하지 않는 코드를 사용하기
  - 자체적으로 인터페이스를 정의
  - API로부터 Controller를 분리 후 어댑터 패턴을 이용해 자체적으로 정의한 인터페이스에 맞출 수 있도록 설정
  - FakeTransmitter을 이용해 Controller를 테스트 -> 추후 공부..
- 깨끗한 경계
  - 경계에 위치하는 코드는 깔끔히 분리하자.
  - 통제가 불가능한 외부 패키지에 의존하는 것 대신 통제가 가능하능한 "우리 코드"에 의존하자.
    - 새로운 클래스로 감싸거나 Adapter 패턴으로 우리의 인터페이스로 변경시켜버리자.

## 9. 단위 테스트

- TDD 법칙 세 가지

  - 첫째 법칙 : 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다,
  - 둘째 법칙 : 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
  - 셋째 법칙 : 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

  - 실제 코드와 맞먹을 정도의 방대한 테스트 코드는 심각한 관리 문제를 초래한다.

- 깨끗한 테스트 코드 유지하기

  - 실제 코드 진화 -> 테스트 코드도 진화 필요
  - 테스트 코드 복잡 -> 테스트 변경 어려움
  - 테스트 케이스 새로 만듬 -> 테스트 케이스 늘어남
  - 테스트 케이스 유지보수 비용 커짐 -> 개발자들의 불만
  - 하지만 자신이 만들거나 수정한 코드가 제대로 돌아가는지 확인하기 위해 테스트는 꼭 필요
  - 이에 따라 깨끗한 코드가 필요

- 테스트는 유연성, 유지보수성, 재사용성을 제공한다.
  - 테스트 케이스 X -> 변경에 대한 버그의 두려움 증가
  - 테스트 케이스 O -> 변경에 대한 버그의 두려움 X
  - 즉, 테스트는 설계와 아키텍처를 최대한 깨끗하게 보존하는 열쇠

- 깨끗한 테스트 코드
  - 가독성이 필수 
    - 명료성, 단순성, 풍부한 표현력
    - BUILD-OPERATE-CHECK 패턴 (테스트 자료 만들기 -> 테스트 자료 조작 -> 결과 확인)
- 도메인에 특화된 테스트 언어
  - 시스템 조작 API 위에 함수와 유틸리티를 구현한 것을 토대로 테스트를 진행하기에 테스트 코드를 만들거나 읽기에 상당히 효율적이다.
    - 테스트를 위한 "특수 API"가 구성되는 것이다.
- 이중 표준
  - 단순하고 간결하고 표현력이 풍부해야하지만 실제 코드만큼 효율적일 필요는 없다. 

- 테스트당 assert 하나
  - assert 문이 단 하나라면 결론이 하나이기에 코드를 이해하기 쉽고 빠르다.
  - 하지만 assert 문을 하나로 병합해야할 필요성이 생긴다.
  - 그렇다면 테스트 케이스를 쪼개서 사용해보자.
  - 하지만 중복되는 코드가 많아진다.
  - assert 문이 적으면 좋긴 하지만 때로는 추가해도 된다. (다만, 최대한 줄이는 방향을 지향하자.)

- 테스트당 개념 하나
  - 테스트 함수마다 한 개념만 테스트
- F.I.R.S.T
  - Fast - 빠르게 
    - 테스트는 빨리 돌아야한다.
  - Independent - 독립적으로
    - 각 테스트는 서로 의존하면 안된다.
    - 의존한다면 하나가 실패하면 다른 하나도 실패할 것이고 원인을 진단하기 어려워진다.
  - Repeatable - 반복가능하게
    - 테스트는 어떤 환경에서도 반복 가능해야한다.
  - Self-Validating - 자가검증하는
    - 부울 값으로 결과를 내야 한다. (Success or Failure)
  - Timely - 적시에
    - 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다.
    - 실제 코드를 구현한 다음에 테스트 코드를 만든다면 실제 코드가 테스트하기 어렵다는 사실을 발견할지도 모른다.



##### 깨끗한 테스트 코드를 만드는 것 자체가 방대하다.

##### 실제 코드만큼이나 중요하므로 깨끗하게 유지하자.

