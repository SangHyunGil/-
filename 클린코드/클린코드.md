## 2. 의미있는 이름

- 의도가 분명한 이름을 지어라.
  - 개념에 명확한 이름을 부여하자.
- 그릇된 정보를 피하라.
  - 보편적인 의미를 다른 의미로서 사용하지말자.
  - 다른 모듈과 흡사한 이름을 사용하지말자.
  - 유사한 개념은 유사한 표기법을 사용하자.
- 의미있게 구분하라.
  - 읽는 사람이 차이를 알도록 네이밍하자.
- 발음하기 쉬운 이름을 사용하라.
- 검색하기 쉬운 이름을 사용하라.

- 인코딩을 피하라.
  - 헝가리식 표기 , 멤버 변수 접두어 -> 구닥다리---
- 클래스 이름, 객체 이름
  - 명사 or 명사구 + 동사 피하자.
  - ex) Customer ... 
- 메서드 이름
  - 동사 or 동사구
  - 정적 팩토리 메서드를 적극 활용하자.

- 한 개념에 한 단어를 사용하라.
  - 일관성 있는 어휘를 사용하자.
- 한 단어를 두 가지 목적으로 사용하지 마라.
- 해법 영역에서 가져온 이름을 사용하라.
- 문제 영역에서 가져온 이름을 사용하라.

- 의미 있는 맥락을 추가하라.



## 3. 함수

- 작게 만들어라.
  - 들여쓰기 수준은 1단이나 2단을 넘어서지 말자.
- 한 가지만 해라.
  - 한 가지라는 것은 추상화의 기준을 말한다.
- 함수 당 추상화 수준은 하나로!
  - 추상화 수준이 섞지 말자.
  - 추상화 수준은 단계별로 내려가도록 구성하자.
- Switch문의 사용은 자제하자.
  - 사용한다면 객체를 생성하는 팩토리로 사용하자.
- 서술적인 이름을 사용하자.
- 함수 인수는 최대한 적게 하자.
  - 플래그를 자제하자.
- 부수 효과를 일으키지 마라.
- 명령과 조회를 분리하라.
- 오류 코드보다 예외를 사용하라.
- 반복하지 마라.



## 4. 주석

- 주석은 실패를 도와주는 보조제일뿐이다.
  - 주석은 최대한 줄이되 코드를 정확하게 짜자.
- 주석은 나쁜 코드를 보완하지 못한다.
  - 오히려 주석없고 깔끔한 코드가 더 낫다.

- 코드로 의도를 표현하라.
- 좋은 주석
  - 법적인 주석 - 회사가 정립한 구현 표준에 맞춰 법적인 이유로 주석을 넣는 것
  - 정보를 제공하는 주석 - 주석이 필요없는 코드를 만든다면 더 좋지 않겠는가?
  - 의도를 설명하는 주석
  - 의미를 명료하게 밝히는 주석
  - 결과를 경고하는 주석
  - TODO 주석 - 떡칠한다면 좋은 코드가 되지 못한다.
  - 중요성을 강조하는 주석
  - 공개 API에서 JavaDocs

- 나쁜 주석

  - 주절거리는 주석
    - 주석을 달기로 다짐했다면 최선을 다해서 달자. 단순 과정이라 생각해서 대충할 생각은 버리자.
  - 같은 이야기를 중복하는 주석
  - 오해할 여지가 있는 주석
  - 의무적으로 다는 주석
  - 있으나 마나 한 주석

  - 무서운 잡음
  - 위치를 표시하는 주석
    - 가끔 다는 배너는 나쁘지 않다.
  - 닫는 괄호에 다는주석
    - 작고 캡슐화된 함수에는 잡음일 뿐이기에, 차라리 함수를 줄이자.
  - 공로를 돌리거나 저자를 표시하는 주석
  - 주석으로 처리한 코드
  - HTML 주석
  - 전역정보
    - 근처에 있는 코드만 기술하고 시스템의 전반적인 정보를 기술하지 마라.
  - 너무 많은 정보
  - 모호한 관계
  - 함수 헤더
  - 비공개 코드에서 Javadocs



## 5. 형식 맞추기

- 코드 형식은 의사소통의 일환이다. 

- 코드는 유지보수와 확장에 지대한 영향을 끼치기에 중요하다.

- 적절한 행 길이를 유지하라.
- 신문 기사처럼 작성하라.
  - 이름은 간단하면서도 설명이 가능하게
  - 고차원 개념 -> 저차원 개념
  - 일정한 형식으로
- 개념은 빈 행으로 분리하라.
  - 빈 행은 새로운 개념을 시작한다는 시각적 단서
- 세로 밀집도
  - 세로 밀집도는 연관성을 의미
- 수직 거리
  - 서로 밀접한 개념은 세로로 가까이 둬야 한다.
  - 서로 밀접한 개념은 한 파일에 속해야 한다. (protected 변수를 피해야 하는 이유)
  - 변수는 사용하는 곳에 최대한 가까이 선언한다.
  - 인스턴스 변수는 클래스 맨 처음에 선언한다.
  - 종속 함수 -> 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다.
  - 개념적 유사성 -> 개념적 친화도가 높을수록 가까이 배치한다.
    - 종속 함수와 같은 직접적인 종속성
    - 비슷한 동작
- 세로 순서
  - 호출되는 함수를 호출하는 함수보다 나중에 배치한다.
    - 고차원 -> 저차원 (자연스럽게)
- 가로 형식 맞추기
- 가로 공백과 밀집도
  - 할당문 "=" 좌우에는 공백 -> 나뉜다는 명백한 사실
  - 함수 인자가 하나일시 공백 X -> 상당히 밀접한다는 사실
  - 인자가 여러개일시 공백으로 구분

- 가로 정렬
  - 정렬은 오히려 읽는데 방해를 준다.

- 들여쓰기
  - 범위를 표현하기 위함이다.
  - 가독성에 큰 영향을 준다.
- 가짜 범위
  - 세미콜론을 제대로 사용하자.

## 6. 객체와 자료구조

- 자료 추상화
  - 자료를 세세하게 공개하기보다는 추상적인 개념으로 표현하는 편이 좋다.
  - 아무 생각 없는 Getter/Setter는 독이다.
- 자료/객체 비대칭
  - 객체 -> 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개
  - 자료 구조 -> 자료를 그대로 공개하며 별다른 함수 제공 X
  - 절차지향과 객체지향 사이의 딜레마
    - 절차지향
      - 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다.
      - 새로운 자료 구조를 추가하기 어렵다.
    - 객체지향
      - 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.
      - 새로운 함수를 추가하기 위해 모든 클래스를 수정해야한다.

- 디미터 법칙
  - 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다. (여러 개의 도트를 사용하지 말자.)
  - User(Class) -> Address(class) -> region(instance variable)
    - user.getAddress().getRegion() => 디미터의 법칙 어김
    - User 내부에 Address를 확인하는 isXXXXX()를 만들어 이를 활용 (불필요한 Getter/Setter 제거)
- 잡종 구조
  - 절반은 객체, 절반은 자료 구조
    - 비공개 변수를 그대로 노출하는 위험
    - 양쪽에서의 단점만 모아놓는 셈
- 구조체 감추기
  - 객체라면 내부 구조를 감춰야한다.

- 자료 전달 객체(DTO)



##### 어떤 시스템을 구현하는데 있어 새로운 자료 타입을 추가하는 유연성이 필요하면 객체

##### 새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합



## 7. 오류 처리

- 오류 코드보다 예외를 사용하라.
  - 오류 코드는 호출자 코드를 복잡하게 만든다.
  - 차라리 예외를 던지자.

- Try-Catch-Finally 문부터 작성하라.
  - 강제로 예외를 일으키는 Test Case를 작성 후 테스트를 통과하게 코드를 작성하는 방법이 좋다.
- 미확인 예외를 사용하라.
  - 확인 예외 -> IOException, ClassNotFound ...
  - 미확인 예외 -> RuntimeException..
  - 확인 예외는 OCP를 위반한다. 
    - 하위에 확인 예외가 존재한다면 상위에서 전부 해당 예외를 선언해야한다.
    - A -> B -> C (IOException !) -> A throws IOException -> B throws IOException -> C Throws IOException
  - 확인 예외는 상위에서 하위의 예외를 "인지"하고 있으므로 "캡슐화"가 깨진다.
- 예외에 의미를 제공하라.
  - 전후 상황을 충분히 붙인다.
  - 로깅 기능을 사용해 catch 블록에 대한 충분한 단서를 남기자.
- 호출자를 고려해 예외 클래스를 정의하라.
  - 외부 API를 사용할 때 감싸기 기법을 사용하라.
    - 외부 API를 감싸면 외부 라이브러리와 프로그램 사이에서의 의존성이 크게 줄어든다.
      - 다른 라이브러리로 바꾸더라도 비용이 적다.

- 정상 흐름을 정의하라.
  - 특수 사례 패턴 -> 클래스를 만들거나 객체를 조작해 특수 사례를 처리

- null을 반환하지 마라.
  - 단순 null 확인이 누락된 부분도 문제가 되지만 null 확인 처리가 "많을 경우"도 문제가 크다.
    - ex) list의 경우 null 대신 빈 리스트를 반환
- null을 전달하지 마라.
  - 애초에 null을 넘기지 않으면 null 처리에 대한 고민의 여지가 줄어든다.



##### 깨끗한 코드란 읽기도 좋아야 하지만 안정성도 높아야 한다.

##### 오류 처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하자.



## 8. 경계

- 외부 코드 사용하기

  - 외부 코드 제공자 -> 범용성 넓게  

  - 외부 코드 사용자 -> 자신에게 맞게 (객체 유형, 필요한 기능)

  - 어떻게 간극을 좁힐까?

    - 객체 유형을 제한하자.

      - 단순 Casting을 하기보다 제네릭스를 사용하면 코드의 가독성이 증가한다.

      - 필요한 기능을 제한해야하는데...?

      - 인터페이스가 변하면 수정할 코드가 상당히 많아질텐데...?

        - 사용자에 맞는 클래스 하나를 정의해 경계 인터페이스를 감싸 숨기자.
          - 필요한 객체유형만 제한
          - 필요한 인터페이스만 제공

        - Map 클래스와 같은 경계 인터페이스들은 생각없이 아무데나 넘기지 말자.

- 경계 살피고 익히기
  - 학습 테스트를 통해 외부 라이브러리를 제대로 학습한 후 적용해보자.
    - 곧바로 우리 코드에 외부 라이브러리를 적용해보는 것이 아니라 간단한 테스트 케이스를 작성하면서 외부 라이브러리를 익히는 것이 학습 테스트이다.
- 학습 테스트는 공짜 이상이다.
  - 패키지 새 버전이 나온다면 학습 테스트를 통해 차이가 있는지 검증 가능하다.

- 아직 존재하지 않는 코드를 사용하기
  - 자체적으로 인터페이스를 정의
  - API로부터 Controller를 분리 후 어댑터 패턴을 이용해 자체적으로 정의한 인터페이스에 맞출 수 있도록 설정
  - FakeTransmitter을 이용해 Controller를 테스트 -> 추후 공부..
- 깨끗한 경계
  - 경계에 위치하는 코드는 깔끔히 분리하자.
  - 통제가 불가능한 외부 패키지에 의존하는 것 대신 통제가 가능하능한 "우리 코드"에 의존하자.
    - 새로운 클래스로 감싸거나 Adapter 패턴으로 우리의 인터페이스로 변경시켜버리자.

## 9. 단위 테스트

- TDD 법칙 세 가지

  - 첫째 법칙 : 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다,
  - 둘째 법칙 : 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
  - 셋째 법칙 : 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

  - 실제 코드와 맞먹을 정도의 방대한 테스트 코드는 심각한 관리 문제를 초래한다.

- 깨끗한 테스트 코드 유지하기

  - 실제 코드 진화 -> 테스트 코드도 진화 필요
  - 테스트 코드 복잡 -> 테스트 변경 어려움
  - 테스트 케이스 새로 만듬 -> 테스트 케이스 늘어남
  - 테스트 케이스 유지보수 비용 커짐 -> 개발자들의 불만
  - 하지만 자신이 만들거나 수정한 코드가 제대로 돌아가는지 확인하기 위해 테스트는 꼭 필요
  - 이에 따라 깨끗한 코드가 필요

- 테스트는 유연성, 유지보수성, 재사용성을 제공한다.
  - 테스트 케이스 X -> 변경에 대한 버그의 두려움 증가
  - 테스트 케이스 O -> 변경에 대한 버그의 두려움 X
  - 즉, 테스트는 설계와 아키텍처를 최대한 깨끗하게 보존하는 열쇠

- 깨끗한 테스트 코드
  - 가독성이 필수 
    - 명료성, 단순성, 풍부한 표현력
    - BUILD-OPERATE-CHECK 패턴 (테스트 자료 만들기 -> 테스트 자료 조작 -> 결과 확인)
- 도메인에 특화된 테스트 언어
  - 시스템 조작 API 위에 함수와 유틸리티를 구현한 것을 토대로 테스트를 진행하기에 테스트 코드를 만들거나 읽기에 상당히 효율적이다.
    - 테스트를 위한 "특수 API"가 구성되는 것이다.
- 이중 표준
  - 단순하고 간결하고 표현력이 풍부해야하지만 실제 코드만큼 효율적일 필요는 없다. 

- 테스트당 assert 하나
  - assert 문이 단 하나라면 결론이 하나이기에 코드를 이해하기 쉽고 빠르다.
  - 하지만 assert 문을 하나로 병합해야할 필요성이 생긴다.
  - 그렇다면 테스트 케이스를 쪼개서 사용해보자.
  - 하지만 중복되는 코드가 많아진다.
  - assert 문이 적으면 좋긴 하지만 때로는 추가해도 된다. (다만, 최대한 줄이는 방향을 지향하자.)

- 테스트당 개념 하나
  - 테스트 함수마다 한 개념만 테스트
- F.I.R.S.T
  - Fast - 빠르게 
    - 테스트는 빨리 돌아야한다.
  - Independent - 독립적으로
    - 각 테스트는 서로 의존하면 안된다.
    - 의존한다면 하나가 실패하면 다른 하나도 실패할 것이고 원인을 진단하기 어려워진다.
  - Repeatable - 반복가능하게
    - 테스트는 어떤 환경에서도 반복 가능해야한다.
  - Self-Validating - 자가검증하는
    - 부울 값으로 결과를 내야 한다. (Success or Failure)
  - Timely - 적시에
    - 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다.
    - 실제 코드를 구현한 다음에 테스트 코드를 만든다면 실제 코드가 테스트하기 어렵다는 사실을 발견할지도 모른다.



##### 깨끗한 테스트 코드를 만드는 것 자체가 방대하다.

##### 실제 코드만큼이나 중요하므로 깨끗하게 유지하자.



## 10. 클래스

- 클래스 체계
  - 순서
    - 정적 공개 상수
    - 정적 비공개 상수
    - 비공개 인스턴스 변수
    - 공개 인스턴스 변수
    - 공개 함수
    - 비공개 함수 (자신이 호출하는 공개 함수 직후) => 추상화 단계가 순차적으로 내려가게끔
  - 캡슐화
    - 변수와 유틸리티 함수는 웬만하면 숨기자.
- 클래스는 작아야 한다.
  - 함수와 마찬가지로 작아야한다.
  - 함수는 물리적인 행 수로 크기를 측정하지만 클래스는 책임이라는 척도를 쓴다.
  - 클래스에서 단순 메소드가 책임이라고 보기 힘들다. 
  - 클래스 이름은 해당 클래스 책임을 기술해야 한다.
    - 클래스 이름이 크기를 줄여주는 포인트가 된다.
    - 클래스의 이름이 해당 책임을 기술하는데 ~며와 같이 많은 책임을 줄 경우 적절하지 못한 케이스이다.
- 단일 책임 원칙(SRP)
  - 클래스나 모듈을 변경할 이유가 단 하나여야 한다.
  - ~며와 같이 책임이 2가지 이상이 섞이는 경우 => 좋지 않다.
  - 돌아가는 소프트웨어를 넘어 깨끗하고 체계적인 소프트웨어로 향해야한다. 이것이 독자에게 가독성을 높이는 길이다.
  - 책임을 쪼개다 보면 수 많은 컴포넌트들이 흘러넘쳐 오히려 우리의 가독성을 해치지 않을까라는 말은 오산이다.
  - 결국 해당 컴포넌트들은 하나에 둘러쌓여 있을 뿐이고 개수는 비슷하다.
  - 시스템이 커진다면 개수는 비슷하지만 우리를 헷갈리게 할 뿐이기에 쪼개는 것은 무조건적으로 바람직하다.
- 응집도
  - 클래스는 인스턴스 변수 수가 작아야 한다.
  - 각 클래스 메서드는 클래스 인스턴스 변수를 하나 이상 사용해야 한다. 
  - 메서드가 인스턴스 변수를 많이 사용할수록 응집도가 올라간다고 한다.
  - 하지만, 메서드와 매개변수 목록을 짧게 하다 보면 인스턴스 변수를 적게 사용하고 쪼개진 메서드의 개수만큼 인스턴스 변수가 늘어나기에 클래스를 쪼개 응집도를 높이자.
- 응집도를 유지하면 작은 클래스 여럿이 나온다.
  - 큰 함수를 쪼개는 데 있어 큰 함수의 변수 여러가지를 작은 함수의 인자로 넘길 생각 없이 인스턴스 변수로 승격시켜 쪼개자.
  - 그렇다면 클래스의 응집도가 떨어지는데 이를 막기 위해 독자적인 클래스로 분리해버리자.
  - 그러면 오히려 프로그램의 체계성이 증진되고 구조가 투명해질 것이다.

- 변경하기 쉬운 클래스
  - 시스템은 지속적인 변경이 발생하는데 깨끗한 시스템은 위험을 줄여준다.
  - 최소 단위로 쪼갠다면 예를 들어 상속을 통해 쪼개진다면 SRP를 만족할 뿐 아니라 OCP도 만족할 수 있다.

- 변경으로부터 격리
  - 인터페이스와 추상 클래스를 사용해 구현이 미치는 영향을 격리한다.
  - 인터페이스와 추상 클래스를 사용해 추상화 정도를 높이면 결합도가 낮아진다.
  - 결합도가 낮아지면 자연스럽게 DIP를 준수하게 된다.
  - 자주 바뀔 가능성이 존재하는 외부 API를 사용할 때 인터페이스를 구현하여 해당 부분에 대한 추상화 정도를 높이면 변경에 대한 여파가 줄어든다.



## 11. 시스템

- 시스템 제작과 시스템 사용을 분리하라.
  - 관심사를 분리하라.
- Main 분리
  - 시스템 생성과 시스템 사용을 분리하는 한 가지 방법으로, 생성과 관련된 코드는 모두 main이나 main이 호출하는 모듈로 옮긴다.
  - 나머지 시스템은 모든 객체가 생성되었고 모든 의존성이 연결되었다고 가정한다.

- 팩토리
  - 객체가 생성되는 시점을 애플리케이션이 결정할 필요도 생긴다.
  - 애플리케이션은 인터페이스를 활용하여 main에 존재하는 구현체에게 실제 생성을 요청하여 받는다.
  - 애플리케이션은 객체가 생성되는 방법을 모르는데도 객체 생성에 대한 시점을 완벽하게 통제하며 사용하는 생성자 인수 또한 넘길 수 있다.

- 의존성 주입
  - 사용과 제작을 분리하는 강력한 메커니즘
  - IoC를 의존성 관리에 적용한 메커니즘
    - Spring FrameWork에서 Spring에게 객체에 대한 전권을 넘겨 객체의 의존성을 관리해주는 것을 의미



- 확장
- 횡단 관심사
- 

---

조금의 공부 후 추후 다시 읽기



## 12. 창발성

- 모든 테스트를 실행한다.
  - 설계는 의도한 대로 돌아가는 시스템을 내놓아야 한다.
  - 테스트가 가능한 시스템을 만들려고 애쓰면 품질이 좋아지며 크기가 작고 목적 하나만 수행하는 클래스가 나온다.
  - 철저한 테스트가 가능한 시스템을 구축하면 더 나은 설계로 이어진다.
  - 결합도가 높으면 테스트 케이스를 작성하기 어렵다. 
    - DIP, DI, 추상화, 인터페이스와 같은 도구로 결합도를 낮추자.
  - 테스트 케이스를 만들고 계쏙 돌리면 낮은 결합도와 높은 응집력이 저절로 달성된다.
- 리팩터링
  - 중복을 없앤다.
    - 똑같은 코드
    - 구현 중복
  - 표현하라.
    - 코드는 개발자의 의도를 분명히 표현해야 한다.
    - 좋은 이름을 선택한다.
    - 함수와 클래스 크기를 가능한 줄인다.
    - 표준 명칭을 사용한다.
    - 단위 테스트 케이스를 꼼꼼히 작성한다.
  - 클래스와 메서드 수를 최소로 줄인다.
    - 목표는 함수와 클래스 크기를 작게 유지하면서 동시에 시스템 크기도 작게 유지하는데 있다.
    - 테스트 케이스, 중복 제거, 의도 표현 > 클래스와 함수 크기 줄이기



---

## 13. 동시성

- 동시성이 필요한 이유?
  - 동시성은 결합을 없애는 전략이다.
    - 무엇과 언제를 분리하는 전략
  - 웹 서버에서의 서블릿을 보면, 각 서블릿  스레드는 다른 서블릿 스레드와 무관하게 돌아간다.
  - 병렬 처리는 필요하다.
- 미신과 오해
  - 동시성은 항상 성능을 높여준다?
    - 때로는 성능을 높여준다.
      - 대기시간이 긴 경우, 여러 스레드가 프로세서를 공유할 수 있거나, 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우 맞다.
    - 동시성을 구현해도 설계는 변하지 않는다.
      - 단일 스레드 시스템과 다중 스레드 시스템은 설계가 판이하게 다르다.
    - 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.
      - 실제 컨테이너가 어떻게 동작하는지, 어떻게 동시 수정, 데드락 등과 같은 문제를 피할 수 있는지 알아야만 한다.
- 타당한 생각
  - 동시성은 다소 부하를 유발한다.
    - 성능 측면에서 부하가 발생하며 코드도 더 짜야한다.
  - 동시성은 복잡하다.
    - 간단한 문제라도 동시성은 복잡하다.
  - 일반적으로 동시성 버그는 재현하기 어렵다.
    - 일회성 문제로 여겨 무시하기 쉽다.
  - 동시성을 구현하려면 흔히 근본적이 설계 전략을 재고해야 한다.

- 동시성 방어 원칙
  - 단일 책임 원칙
    - 메서드/클래스/컴포넌트를 변경할 이유가 하나여야 한다.
    - 동시성 관련 코드는 다른 코드와 분리해야 한다.
    - 동시성 코드는 독자적인 개발, 변경, 조율 주기가 있다.
    - 동시성 코드에는 독자적인 난관이 있다. (다른 코드에서 겪는 난관과 다르며 어렵다.)
    - 잘못 구현한 동시성 코드느 별의별 방식으로 실패한다. 
    - 즉, 다른 코드와 분리하라.
  - 따름 정리 : 자료 범위를 제한하라.
    - 코드 내 임계영역을 키워드로 보호하라.
    - 공유 자료를 수정하는 위치가 많다면?
      - 보호할 임계영역을 빼먹어 공유 자료를 수정하는 모든 코드를 망가뜨린다.
      - 모든 임계영역을 올바르게 보호했는지 확인하느라 똑같은 노력과 수고를 반복한다.
      - 찾아내기 어려운 버그가 더욱 찾기 어려워 진다.
      - 즉, 자료를 캡슐화하고 공유 자료를 최대한 줄여라.
  - 따름 정리 : 자료 사본을 사용하라.
    - 공유 자료를 애초에 공유하지 않는 것이 제일 좋다.
    - 객체를 복사해 읽기 전용으로 사용하는 방법이 가능하다.
  - 따름 정리 : 스레드는 가능한 독립적으로 구현하라.
    - 다른 스레드와 자료를 공유하지 않도록한다.
    - 독자적인 스레드로 가능하면 다른 프로세서에서 돌려도 괜ㅊ낳도록 자료를 독립적인 단위로 분할하라.

- 라이브러리를 이해하라.
  - 스레드 환경에 안전한 컬렉션
    - java.util.concurrent 패키지에 존재한다.
      - ConcurrentHashMap
        - 동시 읽기/쓰기를 지원하며 자주 사용하는 복합 연산을 다중 스레드 상에서 안전하게 만든 메서드로 제공
    - 언어가 제공하는 클래스를 검토하라.
- 실행 모델을 이해하라.
